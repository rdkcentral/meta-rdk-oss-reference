From 8149fd9a384d9805647502f7172d8d7678b31638 Mon Sep 17 00:00:00 2001
From: skondu363 <Srihariraghava_konduritirumala@comcast.com>
Date: Mon, 7 Oct 2024 07:58:12 +0000
Subject: [PATCH]
From: srihariraghava_konduritirumala@comcast.com 
Source: upstream
        [https://github.com/systemd/systemd/commit/5579f85663d10269e7ac7464be6548c99cea4ada#diff-3270cf3ccf2fee1a2130cbfde87b3eba75f1b3f7d3a5f19b284d33ac15a7e254R844]
CVE : CVE-2017-18078

Signed-off-by: skondu363 <Srihariraghava_konduritirumala@comcast.com>
---
 src/tmpfiles/tmpfiles.c | 36 ++++++++++++++++++++++++++++++++++++
 1 file changed, 36 insertions(+)

diff --git a/src/tmpfiles/tmpfiles.c b/src/tmpfiles/tmpfiles.c
index 2053d35a67..b93364f7d8 100644
--- a/src/tmpfiles/tmpfiles.c
+++ b/src/tmpfiles/tmpfiles.c
@@ -604,6 +604,32 @@ finish:
         return r;
 }
 
+static bool dangerous_hardlinks(void) {
+        _cleanup_free_ char *value = NULL;
+        static int cached = -1;
+        int r;
+        /* Check whether the fs.protected_hardlinks sysctl is on. If we can't determine it we assume its off, as that's
+         * what the upstream default is. */
+        if (cached >= 0)
+                return cached;
+        r = read_one_line_file("/proc/sys/fs/protected_hardlinks", &value);
+        if (r < 0) {
+                log_debug_errno(r, "Failed to read fs.protected_hardlinks sysctl: %m");
+                return true;
+        }
+        r = parse_boolean(value);
+        if (r < 0) {
+                log_debug_errno(r, "Failed to parse fs.protected_hardlinks sysctl: %m");
+                return true;
+        }
+        cached = r == 0;
+        return cached;
+}
+static bool hardlink_vulnerable(struct stat *st) {
+        assert(st);
+        return !S_ISDIR(st->st_mode) && st->st_nlink > 1 && dangerous_hardlinks();
+}
+
 static int path_set_perms(Item *i, const char *path) {
         _cleanup_close_ int fd = -1;
         struct stat st;
@@ -623,6 +649,11 @@ static int path_set_perms(Item *i, const char *path) {
         if (fstatat(fd, "", &st, AT_EMPTY_PATH) < 0)
                 return log_error_errno(errno, "Failed to fstat() file %s: %m", path);
 
+        if (hardlink_vulnerable(&st)) {
+                log_error("Refusing to set permissions on hardlinked file %s while the fs.protected_hardlinks sysctl is turned off.", path);
+                return -EPERM;
+        }	
+
         if (S_ISLNK(st.st_mode))
                 log_debug("Skipping mode an owner fix for symlink %s.", path);
         else {
@@ -814,6 +845,11 @@ static int path_set_acls(Item *item, const char *path) {
         if (fstatat(fd, "", &st, AT_EMPTY_PATH) < 0)
                 return log_error_errno(errno, "Failed to fstat() file %s: %m", path);
 
+	if (hardlink_vulnerable(&st)) {
+                log_error("Refusing to set ACLs on hardlinked file %s while the fs.protected_hardlinks sysctl is turned off.", path);
+                return -EPERM;
+        }
+
         if (S_ISLNK(st.st_mode)) {
                 log_debug("Skipping ACL fix for symlink %s.", path);
                 return 0;
