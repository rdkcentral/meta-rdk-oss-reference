From: dbhat852_comcast <Deepika_Bhat@comcast.com>
Date: Jul 30, 2024 1:50 PM
Source: https://bazaar.launchpad.net/~ecryptfs/ecryptfs/trunk/revision/870#

Index: ecryptfs-utils-106/src/utils/mount.ecryptfs_private.c
===================================================================
--- ecryptfs-utils-106.orig/src/utils/mount.ecryptfs_private.c
+++ ecryptfs-utils-106/src/utils/mount.ecryptfs_private.c
@@ -30,6 +30,7 @@
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/vfs.h>
 #include <ctype.h>
 #include <errno.h>
 #include <keyutils.h>
@@ -219,6 +220,61 @@ err:
 	}
 	return NULL;
 }
+static int check_cwd_f_type()
+{
+	/**
+	 * This is *not* a list of compatible lower filesystems list for
+	 * eCryptfs. This is a list of filesystems that we reasonably expect to
+	 * see mount.ecryptfs_private users mounting on top of. In other words,
+	 * the filesystem type of the 'target' parameter of mount(2).
+	 *
+	 * This whitelist is to prevent malicious mount.ecryptfs_private users
+	 * from mounting over filesystem types such as PROC_SUPER_MAGIC to
+	 * deceive other programs with a crafted /proc/self/*. See
+	 * https://launchpad.net/bugs/1530566 for more details.
+	 */ 
+	__SWORD_TYPE f_type_whitelist[] = {
+		0x61756673 /* AUFS_SUPER_MAGIC */,
+		0x9123683E /* BTRFS_SUPER_MAGIC */,
+		0x00C36400 /* CEPH_SUPER_MAGIC */,
+		0xFF534D42 /* CIFS_MAGIC_NUMBER */,
+		0x0000F15F /* ECRYPTFS_SUPER_MAGIC */,
+		0x0000EF53 /* EXT[234]_SUPER_MAGIC */,
+		0xF2F52010 /* F2FS_SUPER_MAGIC */,
+		0x65735546 /* FUSE_SUPER_MAGIC */,
+		0x01161970 /* GFS2_MAGIC */,
+		0x3153464A /* JFS_SUPER_MAGIC */,
+		0x0000564C /* NCP_SUPER_MAGIC */,
+		0x00006969 /* NFS_SUPER_MAGIC */,
+		0x00003434 /* NILFS_SUPER_MAGIC */,
+		0x5346544E /* NTFS_SB_MAGIC */,
+		0x794C7630 /* OVERLAYFS_SUPER_MAGIC */,
+		0x52654973 /* REISERFS_SUPER_MAGIC */,
+		0x73717368 /* SQUASHFS_MAGIC */,
+		0x01021994 /* TMPFS_MAGIC */,
+		0x58465342 /* XFS_SB_MAGIC */,
+		0x2FC12FC1 /* ZFS_SUPER_MAGIC */,
+	};
+	struct statfs buf;
+	size_t i, whitelist_len;
+
+	if (statfs(".", &buf) != 0) {
+		fprintf(stderr, "Failed to check filesystem type: %m\n");
+		return 1;
+	}
+
+	whitelist_len = sizeof(f_type_whitelist) / sizeof(*f_type_whitelist);
+	for (i = 0; i < whitelist_len; i++) {
+		if (buf.f_type == f_type_whitelist[i]) {
+			return 0;
+		}
+	}
+
+	fprintf(stderr,
+			"Refusing to mount over an unapproved filesystem type: %#lx\n",
+			buf.f_type);
+	return 1;
+}
 
 int check_ownership_mnt(uid_t uid, char **mnt) {
 /* Check ownership of mount point, chdir into it, and
@@ -626,8 +682,11 @@ int main(int argc, char *argv[]) {
 	/* Check ownership of the mountpoint. From here on, dest refers
 	 * to a canonicalized path, and the mountpoint is the cwd. */
 	if (check_ownership_mnt(uid, &dest) != 0) {
- 		goto fail;
- 	}
+		goto fail;
+	}
+	if (check_cwd_f_type() != 0) {
+		goto fail;
+	}
 
 	if (mounting == 1) {
 		/* Increment mount counter, errors non-fatal */
