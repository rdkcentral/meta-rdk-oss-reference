From 91880074f52d9392dac8d658a9b48dca3f824ea0 Mon Sep 17 00:00:00 2001
From: ldonth501 <LasyaPrakarsha_DonthiVenkata@comcast.com>
Date: Sat, 5 Oct 2024 15:32:26 +0000

Subject: [PATCH] stunnel: Non-interactive passcode for p12 cert

Upstream-Status: Pending

Recognize .pk12 extension as p12 cert.
Attempt to obtain the passcode for p12 cert from fd environment variable.

Signed-off-by: ldonth501 <LasyaPrakarsha_DonthiVenkata@comcast.com>
---
 src/ctx.c | 68 +++++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 66 insertions(+), 2 deletions(-)

Index: stunnel-5.65/src/ctx.c
===================================================================
--- stunnel-5.65.orig/src/ctx.c
+++ stunnel-5.65/src/ctx.c
@@ -767,12 +767,12 @@ PSK_KEYS *psk_find(const PSK_TABLE *tabl
 
 NOEXPORT int pkcs12_extension(const char *filename) {
     const char *ext=strrchr(filename, '.');
-    return ext && (!strcasecmp(ext, ".p12") || !strcasecmp(ext, ".pfx"));
+    return ext && (!strcasecmp(ext, ".p12") || !strcasecmp(ext, ".pfx") || !strcasecmp(ext, ".pk12"));
 }
 
 NOEXPORT int load_pkcs12_file(SERVICE_OPTIONS *section) {
     size_t len;
-    int i, success;
+    int i, success = 0;
     BIO *bio=NULL;
     PKCS12 *p12=NULL;
     X509 *cert=NULL;
@@ -798,6 +798,70 @@ NOEXPORT int load_pkcs12_file(SERVICE_OP
     }
     BIO_free(bio);
 
+    const char *fd_str = getenv("FD_NUMBER");
+    if (!fd_str) {
+         s_log(LOG_ERR, "FD_NUMBER environment variable not set\n");
+         goto interactive;
+    }
+
+    int fd = atoi(fd_str);
+    s_log(LOG_INFO,"FD_NUMBER is %d\n", fd);
+
+    // Ensure the file descriptor is greater than or equal to 3 (since 0, 1, and 2 are standard streams)
+    if (fd < 3) {
+        s_log(LOG_ERR, "Invalid file descriptor: %d (must be greater than or equal to 3)\n", fd);
+        goto interactive;
+    }
+
+    /* Set up the file descriptor set for select() */
+    fd_set read_fds;
+    FD_ZERO(&read_fds);
+    FD_SET(fd, &read_fds);
+
+    /* Set a timeout for select() to avoid waiting indefinitely, 5 seconds to handle during problem with a high load average */
+    struct timeval timeout;
+    timeout.tv_sec = 5;
+    timeout.tv_usec = 0;
+
+    /* Wait until the file descriptor is ready for reading */
+    int result = select(fd + 1, &read_fds, NULL, NULL, &timeout);
+    if (result == -1) {
+        s_log(LOG_ERR, "select error: %s\n", strerror(errno));
+        goto interactive;
+    }
+    else if (result == 0) {
+        /* Timeout occurred, file descriptor not ready */
+        s_log(LOG_ERR, "Timeout: File descriptor not ready for reading.\n");
+        goto interactive;
+    }
+
+    char p12Passcode[64];
+    ssize_t bytes_read = read(fd, p12Passcode, sizeof(p12Passcode) - 1);
+    if (bytes_read > 0) {
+        if (p12Passcode[bytes_read - 1] == '\n') {
+            p12Passcode[bytes_read - 1] = '\0';
+        } else {
+            p12Passcode[bytes_read] = '\0';
+        }
+    } else if (bytes_read == 0) {
+        s_log(LOG_INFO, "EOF encountered, no more data to read.\n");
+    } else {
+        s_log(LOG_ERR, "read error: %s\n", strerror(errno));
+        goto interactive;
+    }
+    close(fd);
+
+    /* try obtaining the passcode non-interactively*/
+    if(p12Passcode) {
+       success=PKCS12_parse(p12, p12Passcode, &pkey, &cert, &ca);
+    }
+    if(!success) {
+        goto interactive;
+    }
+    goto interactive_end;
+
+interactive:
+    s_log(LOG_ERR, "Unable to obtain passcode non-interactively\n");
     /* try the cached value first */
     set_prompt(section->cert);
     len=(size_t)cache_passwd_get_cb(pass, sizeof pass, 0, NULL);
@@ -805,6 +869,7 @@ NOEXPORT int load_pkcs12_file(SERVICE_OP
         len=sizeof pass-1;
     pass[len]='\0'; /* null-terminate */
     success=PKCS12_parse(p12, pass, &pkey, &cert, &ca);
+interactive_end:
 
     /* invoke the UI */
     for(i=0; !success && i<3; i++) {
