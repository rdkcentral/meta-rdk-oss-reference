From 4085e0009865d9f3d17472f3f6232fbbd571df94 Mon Sep 17 00:00:00 2001
From: skondu363 <Srihariraghava_konduritirumala@comcast.com>
Date: Thu, 3 Oct 2024 07:41:38 +0000
Subject: [PATCH]
Source: upstream
Upstream-Status:Backport from [https://gitlab.com/gnutls/gnutls/-/commit/40dbbd8de499668590e8af51a15799fbc430595e]
CVE: CVE-2024-0553

Signed-off-by: skondu363 <Srihariraghava_konduritirumala@comcast.com>
---
 lib/auth/rsa_psk.c | 70 ++++++++++++++++++++++------------------------
 1 file changed, 34 insertions(+), 36 deletions(-)

diff --git a/lib/auth/rsa_psk.c b/lib/auth/rsa_psk.c
index d8595a6..5687d4d 100644
--- a/lib/auth/rsa_psk.c
+++ b/lib/auth/rsa_psk.c
@@ -268,7 +268,6 @@ _gnutls_proc_rsa_psk_client_kx(gnutls_session_t session, uint8_t * data,
 	int randomize_key = 0;
 	ssize_t data_size = _data_size;
 	gnutls_psk_server_credentials_t cred;
-	gnutls_datum_t premaster_secret = { NULL, 0 };
 
 	cred = (gnutls_psk_server_credentials_t)
 	    _gnutls_get_cred(session, GNUTLS_CRD_PSK);
@@ -360,56 +359,55 @@ _gnutls_proc_rsa_psk_client_kx(gnutls_session_t session, uint8_t * data,
 
 
 	if (randomize_key != 0) {
-		premaster_secret.size = GNUTLS_MASTER_SIZE;
-		premaster_secret.data =
-		    gnutls_malloc(premaster_secret.size);
-		if (premaster_secret.data == NULL) {
+		/* Find the key of this username. A random value will be
+	         * filled in if the key is not found.
+	         */
+	        ret = _gnutls_psk_pwd_find_entry(session, info->username,
+		         			 &pwd_psk);
+	        if (ret < 0)
+		        return gnutls_assert_val(ret);
+
+	        /* Allocate memory for premaster secret, and fill in the
+	         * fields except the decryption result.
+	         */
+	        session->key.key.size = 2 + GNUTLS_MASTER_SIZE + 2 + pwd_psk.size;
+	        session->key.key.data = gnutls_malloc(session->key.key.size);
+    	        if (session->key.key.data == NULL) {
 			gnutls_assert();
+			_gnutls_free_key_datum(&pwd_psk);
+			/* No need to zeroize, as the secret is not copied in yet */
+			_gnutls_free_datum(&session->key.key);
 			return GNUTLS_E_MEMORY_ERROR;
 		}
 
 		/* we do not need strong random numbers here.
 		 */
-		ret = _gnutls_rnd(GNUTLS_RND_NONCE, premaster_secret.data,
-				  premaster_secret.size);
+		ret = _gnutls_rnd(GNUTLS_RND_NONCE, session->key.key.data + 2,
+				  GNUTLS_MASTER_SIZE);
 		if (ret < 0) {
 			gnutls_assert();
-			goto cleanup;
+			_gnutls_free_key_datum(&pwd_psk);
+			/* No need to zeroize, as the secret is not copied in yet */
+			_gnutls_free_datum(&session->key.key);
+			return ret;
 		}
 	} else {
-		premaster_secret.data = plaintext.data;
-		premaster_secret.size = plaintext.size;
+		memcpy(session->key.key.data + 2, plaintext.data, sizeof(plaintext.data));
 	}
+        
+	_gnutls_write_uint16(GNUTLS_MASTER_SIZE, session->key.key.data);
+	_gnutls_write_uint16(pwd_psk.size,
+			     &session->key.key.data[2 + GNUTLS_MASTER_SIZE]);
+	memcpy(&session->key.key.data[2 + GNUTLS_MASTER_SIZE + 2], pwd_psk.data,
+	       pwd_psk.size);
+	_gnutls_free_key_datum(&pwd_psk);
 
 	/* This is here to avoid the version check attack
 	 * discussed above.
 	 */
-
-	premaster_secret.data[0] = _gnutls_get_adv_version_major(session);
-	premaster_secret.data[1] = _gnutls_get_adv_version_minor(session);
-
-	/* find the key of this username
-	 */
-	ret =
-	    _gnutls_psk_pwd_find_entry(session, info->username, &pwd_psk);
-	if (ret < 0) {
-		gnutls_assert();
-		goto cleanup;
-	}
-
-	ret =
-	    set_rsa_psk_session_key(session, &pwd_psk, &premaster_secret);
-	if (ret < 0) {
-		gnutls_assert();
-		goto cleanup;
-	}
-
-	ret = 0;
-      cleanup:
-	_gnutls_free_key_datum(&pwd_psk);
-	_gnutls_free_temp_key_datum(&premaster_secret);
-
-	return ret;
+	session->key.key.data[2] = _gnutls_get_adv_version_major(session);
+	session->key.key.data[3] = _gnutls_get_adv_version_minor(session);
+	return 0;
 }
 
 static int
