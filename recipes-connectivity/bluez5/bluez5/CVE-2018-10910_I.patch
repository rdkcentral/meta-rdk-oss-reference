Date: Dec 8, 2022
From: Pitty, Chandresh <Chandresh_Pitty@cable.comcast.com>
Source: COMCAST
Subject: Adding the CVE-2018-10910.patch to Address vulnerabilities identified with 'bluez5'
Signed-off-by: Pitty, Chandresh <Chandresh_Pitty@cable.comcast.com>
Index: bluez-5.48/src/adapter.c
===================================================================
--- bluez-5.48.orig/src/adapter.c
+++ bluez-5.48/src/adapter.c
@@ -225,6 +225,7 @@ struct btd_adapter {
 	uint8_t discovery_type;		/* current active discovery type */
 	uint8_t discovery_enable;	/* discovery enabled/disabled */
 	bool discovery_suspended;	/* discovery has been suspended */
+    bool discovery_discoverable;    /* discoverable while discovering */
 	GSList *discovery_list;		/* list of discovery clients */
 	GSList *set_filter_list;	/* list of clients that specified
 					 * filter, but don't scan yet
@@ -1886,6 +1887,20 @@ static bool set_filtered_discoverable(st
        return set_discoverable(adapter, enable, 0);
 }
 
+static bool set_discovery_discoverable(struct btd_adapter *adapter, bool enable)
+{
+   if (adapter->discovery_discoverable == enable)
+       return true;
+
+   /* Reset discoverable filter if already set */
+   if (enable && (adapter->current_settings & MGMT_OP_SET_DISCOVERABLE))
+       return true;
+
+   adapter->discovery_discoverable = enable;
+
+   return set_discoverable(adapter, enable, 0);
+}
+
 static void discovery_remove(struct watch_client *client, bool exit)
 {
 	struct btd_adapter *adapter = client->adapter;
@@ -2157,6 +2172,7 @@ static bool filters_equal(struct mgmt_cp
 static int update_discovery_filter(struct btd_adapter *adapter)
 {
 	struct mgmt_cp_start_service_discovery *sd_cp;
+    GSList *l;
 
 	DBG("");
 
@@ -2166,6 +2182,18 @@ static int update_discovery_filter(struc
 		return -ENOMEM;
 	}
 
+    for (l = adapter->discovery_list; l; l = g_slist_next(l)) {
+        struct watch_client *client = l->data;
+
+        if (!client->discovery_filter)
+            continue;
+
+        if (client->discovery_filter->discoverable)
+            break;
+    }
+
+    set_discovery_discoverable(adapter, l ? true : false);
+
 	/*
 	 * If filters are equal, then don't update scan, except for when
 	 * starting discovery.
@@ -2197,6 +2225,9 @@ static int discovery_stop(struct watch_c
 		return 0;
 	}
 
+    if (adapter->discovery_discoverable)
+            set_discovery_discoverable(adapter, false);
+
 	/*
 	 * In the idle phase of a discovery, there is no need to stop it
 	 * and so it is enough to send out the signal and just return.
@@ -2959,6 +2990,9 @@ static void property_set_discoverable(co
 		return;
 	}
 
+    /* Reset discovery_discoverable as Discoverable takes precedence */
+    adapter->discovery_discoverable = false;
+
 	property_set_mode(adapter, MGMT_SETTING_DISCOVERABLE, iter, id);
 }
 
