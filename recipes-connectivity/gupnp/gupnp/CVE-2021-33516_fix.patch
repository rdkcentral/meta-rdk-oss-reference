Date: Wed, 06 Sep 2023
From: Alluri Revathi Bhavani <RevathiBhavani_Alluri@comcast.com>
Source: upstream
        https://gitlab.gnome.org/GNOME/gupnp/-/commit/05e964d48322ff23a65c6026d656e4494ace6ff9
Prevents DNS rebinding attacs against agains UPnP services

Make sure that the host header matches the ip:port of the context.

This is in line with UDA (Host header is required and must match the
location url) and DLNA 7.2.24.1 (All communication has to use ip
addresses and not names)

From 05e964d48322ff23a65c6026d656e4494ace6ff9 Mon Sep 17 00:00:00 2001
From: Jens Georg <mail@jensge.org>
Date: Mon, 10 May 2021 10:34:36 +0200
Subject: [PATCH] service: Validate host header

 libgupnp/gupnp-context-private.h
 libgupnp/gupnp-context.c
 libgupnp/gupnp-service.c
 3 files changed, 67 insertions(+)
---
Index: gupnp-0.20.10/libgupnp/gupnp-context.c
===================================================================
--- gupnp-0.20.10.orig/libgupnp/gupnp-context.c
+++ gupnp-0.20.10/libgupnp/gupnp-context.c
@@ -1476,3 +1476,67 @@ gupnp_context_unhost_path (GUPnPContext
         soup_server_remove_handler (server, server_path);
         host_path_data_free (path_data);
 }
+
+gboolean
+validate_host_header (const char *host_header,
+                      const char *host_ip,
+                      guint context_port)
+{
+
+        gboolean retval = FALSE;
+        // Be lazy and let GUri do the heavy lifting here, such as stripping the
+        // [] from v6 addresses, splitting of the port etc.
+        char *uri_from_host = g_strconcat ("http://", host_header, NULL);
+
+        const char *host = NULL;
+        int port = 0;
+
+        SoupURI *uri = soup_uri_new (uri_from_host);
+        if (uri == NULL) {
+                g_debug ("Failed to parse HOST header %s from request",
+                         host_header);
+                goto out;
+        }
+        host = soup_uri_get_host (uri);
+        port = soup_uri_get_port (uri);
+
+
+        // -1 means there was no :port; according to UDA this is allowed and
+        // defaults to 80, the HTTP port then
+        if (soup_uri_uses_default_port (uri)) {
+                port = 80;
+        }
+
+        if (!g_str_equal (host, host_ip)) {
+                g_debug ("Mismatch between host header and host IP (%s, "
+                         "expected: %s)",
+                         host,
+                         host_ip);
+        }
+
+        if (port != context_port) {
+                g_debug ("Mismatch between host header and host port (%d, "
+                         "expected %d)",
+                         port,
+                         context_port);
+        }
+
+        retval = g_str_equal (host, host_ip) && port == context_port;
+
+out:
+        g_clear_pointer (&uri, soup_uri_free);
+        g_free (uri_from_host);
+
+        return retval;
+}
+
+gboolean
+gupnp_context_validate_host_header (GUPnPContext *context,
+                                    const char *host_header)
+{
+        return validate_host_header (
+                host_header,
+                gssdp_client_get_host_ip (GSSDP_CLIENT (context)),
+                gupnp_context_get_port (context));
+}
+
Index: gupnp-0.20.10/libgupnp/gupnp-context-private.h
===================================================================
--- gupnp-0.20.10.orig/libgupnp/gupnp-context-private.h
+++ gupnp-0.20.10/libgupnp/gupnp-context-private.h
@@ -29,6 +29,14 @@ G_BEGIN_DECLS
 G_GNUC_INTERNAL const char *
 _gupnp_context_get_server_url (GUPnPContext *context);
 
+G_GNUC_INTERNAL gboolean
+gupnp_context_validate_host_header (GUPnPContext *context, const char *host);
+
+gboolean
+validate_host_header (const char *host_header,
+                      const char *host_ip,
+                      guint context_port);
+
 G_END_DECLS
 
 #endif /* __GUPNP_CONTEXT_PRIVATE_H__ */
Index: gupnp-0.20.10/libgupnp/gupnp-service.c
===================================================================
--- gupnp-0.20.10.orig/libgupnp/gupnp-service.c
+++ gupnp-0.20.10/libgupnp/gupnp-service.c
@@ -987,6 +987,19 @@ control_server_handler (SoupServer
 
         context = gupnp_service_info_get_context (GUPNP_SERVICE_INFO (service));
 
+        const char *host_header =
+                soup_message_headers_get_one (msg->request_headers, "Host");
+
+        if (!gupnp_context_validate_host_header (context, host_header)) {
+                g_warning ("Host header mismatch, expected %s:%d, got %s",
+                           gssdp_client_get_host_ip (GSSDP_CLIENT (context)),
+                           gupnp_context_get_port (context),
+                           host_header);
+
+                soup_message_set_status (msg, SOUP_STATUS_PRECONDITION_FAILED);
+                return;
+        }
+
         /* Get action name */
         soap_action = soup_message_headers_get_one (msg->request_headers,
                                                     "SOAPAction");
Index: gupnp-0.20.10/tests/gtest/test-bugs.c
===================================================================
--- gupnp-0.20.10.orig/tests/gtest/test-bugs.c
+++ gupnp-0.20.10/tests/gtest/test-bugs.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <libgupnp/gupnp.h>
+#include <libgupnp/gupnp-context-private.h>
 
 
 struct _GUPnPServiceAction {
@@ -380,15 +381,83 @@ test_bgo_690400 (void)
     g_object_unref (context);
 }
 
+static void
+test_ggo_24 (void)
+{
+        // IPv4
+        g_assert (
+                validate_host_header ("127.0.0.1:4711", "127.0.0.1", 4711));
+
+        g_assert (
+                validate_host_header ("127.0.0.1", "127.0.0.1", 80));
+
+        g_assert_false (
+                validate_host_header ("example.com", "127.0.0.1", 4711));
+
+        g_assert_false (
+                validate_host_header ("example.com:80", "127.0.0.1", 4711));
+
+        g_assert_false (
+                validate_host_header ("example.com:4711", "127.0.0.1", 4711));
+
+        g_assert_false (
+                validate_host_header ("192.168.1.2:4711", "127.0.0.1", 4711));
+
+        g_assert_false (
+                validate_host_header ("[fe80::01]", "127.0.0.1", 4711));
+
+        // Link ids should not be parsed
+        g_assert_false (
+                validate_host_header ("[fe80::01%1]", "127.0.0.1", 4711));
+
+        g_assert_false (
+                validate_host_header ("[fe80::01%eth0]", "127.0.0.1", 4711));
+
+        // IPv6
+        g_assert (
+                validate_host_header ("[::1]:4711", "::1", 4711));
+
+        g_assert (
+                validate_host_header ("[::1]", "::1", 80));
+
+        // Host header needs to be enclosed in [] even without port
+        g_assert_false (
+                validate_host_header ("::1", "::1", 80));
+
+        g_assert_false (
+                validate_host_header ("example.com", "::1", 4711));
+
+        g_assert_false (
+                validate_host_header ("example.com:80", "::1", 4711));
+
+        g_assert_false (
+                validate_host_header ("example.com:4711", "::1", 4711));
+
+        g_assert_false (
+                validate_host_header ("192.168.1.2:4711", "::1", 4711));
+
+        g_assert_false (
+                validate_host_header ("[fe80::01]", "::1", 4711));
+
+        // Link ids should not be parsed
+        g_assert_false (
+                validate_host_header ("[fe80::01%1]", "fe80::acab", 4711));
+
+        g_assert_false (
+                validate_host_header ("[fe80::01%eth0]", "fe80::acab", 4711));
+}
+
+
 int
 main (int argc, char *argv[]) {
 #if !GLIB_CHECK_VERSION(2,35,0)
     g_type_init ();
 #endif
     g_test_init (&argc, &argv, NULL);
-    g_test_add_func ("/bugs/696762", test_bgo_696762);
-    g_test_add_func ("/bugs/678701", test_bgo_678701);
-    g_test_add_func ("/bugs/690400", test_bgo_690400);
+    g_test_add_func ("/bugs/bgo/696762", test_bgo_696762);
+    g_test_add_func ("/bugs/bgo/678701", test_bgo_678701);
+    g_test_add_func ("/bugs/bgo/690400", test_bgo_690400);
+    g_test_add_func ("/bugs/ggo/24", test_ggo_24);
 
     return g_test_run ();
 }
