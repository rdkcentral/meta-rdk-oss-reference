From 9e87b2346c2d0104e6f664cfdedc8d7bbae5a072 Mon Sep 17 00:00:00 2001
From: Pawel Lampe <pawel.lampe@sky.uk>
Date: Mon, 5 Dec 2022 16:00:39 +0000
Subject: [PATCH] soup3 directory

---
 ext/meson.build                   |    1 +
 ext/soup3/gstsoup.c               |   42 +
 ext/soup3/gstsoupelement.c        |   66 +
 ext/soup3/gstsoupelements.h       |   39 +
 ext/soup3/gstsouphttpclientsink.c |  940 ++++++++++
 ext/soup3/gstsouphttpclientsink.h |   76 +
 ext/soup3/gstsouphttpsrc.c        | 2656 +++++++++++++++++++++++++++++
 ext/soup3/gstsouphttpsrc.h        |  138 ++
 ext/soup3/gstsouploader.c         |  939 ++++++++++
 ext/soup3/gstsouploader.h         |  172 ++
 ext/soup3/gstsouputils.c          |   98 ++
 ext/soup3/gstsouputils.h          |   37 +
 ext/soup3/meson.build             |   30 +
 ext/soup3/stub/soup.h             |  214 +++
 meson_options.txt                 |    1 +
 15 files changed, 5449 insertions(+)
 create mode 100644 ext/soup3/gstsoup.c
 create mode 100644 ext/soup3/gstsoupelement.c
 create mode 100644 ext/soup3/gstsoupelements.h
 create mode 100644 ext/soup3/gstsouphttpclientsink.c
 create mode 100644 ext/soup3/gstsouphttpclientsink.h
 create mode 100644 ext/soup3/gstsouphttpsrc.c
 create mode 100644 ext/soup3/gstsouphttpsrc.h
 create mode 100644 ext/soup3/gstsouploader.c
 create mode 100644 ext/soup3/gstsouploader.h
 create mode 100644 ext/soup3/gstsouputils.c
 create mode 100644 ext/soup3/gstsouputils.h
 create mode 100644 ext/soup3/meson.build
 create mode 100644 ext/soup3/stub/soup.h

diff --git a/ext/meson.build b/ext/meson.build
index 6f5594e..49ff4b1 100644
--- a/ext/meson.build
+++ b/ext/meson.build
@@ -15,6 +15,7 @@ subdir('qt')
 subdir('pulse')
 subdir('shout2')
 subdir('soup')
+subdir('soup3')
 subdir('speex')
 subdir('taglib')
 subdir('twolame')
diff --git a/ext/soup3/gstsoup.c b/ext/soup3/gstsoup.c
new file mode 100644
index 0000000..3faea44
--- /dev/null
+++ b/ext/soup3/gstsoup.c
@@ -0,0 +1,42 @@
+/* GStreamer
+ * Copyright (C) 2007-2008 Wouter Cloetens <wouter@mind.be>
+ * Copyright (C) 2021 Igalia S.L.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <glib/gi18n-lib.h>
+
+#include "gstsoupelements.h"
+#include "gstsouploader.h"
+
+#define GST_ELEMENT_REGISTER(element, plugin) G_PASTE(gst_element_register_, element) (plugin)
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  gboolean ret = FALSE;
+
+  ret |= GST_ELEMENT_REGISTER (souphttpsrc, plugin);
+  ret |= GST_ELEMENT_REGISTER (souphttpclientsink, plugin);
+
+  return ret;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    soup,
+    "libsoup HTTP client src/sink",
+    plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/ext/soup3/gstsoupelement.c b/ext/soup3/gstsoupelement.c
new file mode 100644
index 0000000..bd1ad35
--- /dev/null
+++ b/ext/soup3/gstsoupelement.c
@@ -0,0 +1,66 @@
+/* GStreamer
+ * Copyright (C) 2007-2008 Wouter Cloetens <wouter@mind.be>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <glib/gi18n-lib.h>
+
+#include "gstsoupelements.h"
+#include "gstsouphttpsrc.h"
+#include "gstsouphttpclientsink.h"
+#include "gstsouputils.h"
+
+GST_DEBUG_CATEGORY (soup_utils_debug);
+#define GST_CAT_DEFAULT soup_utils_debug
+
+gboolean
+soup_element_init (GstPlugin * plugin)
+{
+  static gsize res = FALSE;
+
+  if (g_once_init_enter (&res)) {
+    GST_DEBUG_CATEGORY_INIT (soup_utils_debug, "souputils", 0, "Soup utils");
+#ifdef ENABLE_NLS
+    GST_DEBUG ("binding text domain %s to locale dir %s", GETTEXT_PACKAGE,
+        LOCALEDIR);
+    bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
+    bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+#endif
+
+    /* see https://bugzilla.gnome.org/show_bug.cgi?id=674885 */
+    g_type_ensure (G_TYPE_SOCKET);
+    g_type_ensure (G_TYPE_SOCKET_ADDRESS);
+    g_type_ensure (G_TYPE_SOCKET_SERVICE);
+    g_type_ensure (G_TYPE_SOCKET_FAMILY);
+    g_type_ensure (G_TYPE_SOCKET_CLIENT);
+    g_type_ensure (G_TYPE_RESOLVER);
+    g_type_ensure (G_TYPE_PROXY_RESOLVER);
+    g_type_ensure (G_TYPE_PROXY_ADDRESS);
+    g_type_ensure (G_TYPE_TLS_CERTIFICATE);
+    g_type_ensure (G_TYPE_TLS_CONNECTION);
+    g_type_ensure (G_TYPE_TLS_DATABASE);
+    g_type_ensure (G_TYPE_TLS_INTERACTION);
+
+    g_once_init_leave (&res, TRUE);
+  }
+#ifndef STATIC_SOUP
+  if (!gst_soup_load_library ()) {
+    GST_WARNING ("Failed to load libsoup library");
+    return FALSE;
+  }
+#endif
+  return TRUE;
+}
diff --git a/ext/soup3/gstsoupelements.h b/ext/soup3/gstsoupelements.h
new file mode 100644
index 0000000..720f4d3
--- /dev/null
+++ b/ext/soup3/gstsoupelements.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2020 Huawei Technologies Co., Ltd.
+ *   @Author: Julian Bouzas <julian.bouzas@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_SOUP_ELEMENTS_H__
+#define __GST_SOUP_ELEMENTS_H__
+
+#include <gst/gst.h>
+
+#define GST_ELEMENT_REGISTER_DECLARE(element) \
+G_BEGIN_DECLS \
+gboolean G_PASTE(gst_element_register_, element) (GstPlugin * plugin); \
+G_END_DECLS
+
+G_BEGIN_DECLS
+
+gboolean soup_element_init (GstPlugin * plugin);
+
+GST_ELEMENT_REGISTER_DECLARE (souphttpsrc);
+GST_ELEMENT_REGISTER_DECLARE (souphttpclientsink);
+
+G_END_DECLS
+
+#endif /* __GST_SOUP_ELEMENTS_H__ */
diff --git a/ext/soup3/gstsouphttpclientsink.c b/ext/soup3/gstsouphttpclientsink.c
new file mode 100644
index 0000000..14d69e6
--- /dev/null
+++ b/ext/soup3/gstsouphttpclientsink.c
@@ -0,0 +1,940 @@
+/* GStreamer
+ * Copyright (C) 2011 David Schleef <ds@entropywave.com>
+ * Copyright (C) 2021 Igalia S.L.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
+ * Boston, MA 02110-1335, USA.
+ */
+/**
+ * SECTION:element-gstsouphttpclientsink
+ * @title: gstsouphttpclientsink
+ *
+ * The souphttpclientsink element sends pipeline data to an HTTP server
+ * using HTTP PUT commands.
+ *
+ * ## Example launch line
+ * |[
+ * gst-launch-1.0 -v videotestsrc num-buffers=300 ! theoraenc ! oggmux !
+ *   souphttpclientsink location=http://server/filename.ogv
+ * ]|
+ *
+ * This example encodes 10 seconds of video and sends it to the HTTP
+ * server "server" using HTTP PUT commands.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/base/gstbasesink.h>
+#include <gio/gio.h>
+
+#include "gstsoupelements.h"
+#include "gstsouphttpclientsink.h"
+#include "gstsouputils.h"
+
+#define GST_ELEMENT_REGISTER_DEFINE_CUSTOM(element, register_func) \
+G_BEGIN_DECLS \
+gboolean G_PASTE (gst_element_register_, element) (GstPlugin * plugin) \
+{ \
+  return register_func (plugin); \
+} \
+G_END_DECLS
+
+GST_DEBUG_CATEGORY_STATIC (souphttpclientsink_dbg);
+#define GST_CAT_DEFAULT souphttpclientsink_dbg
+
+/* prototypes */
+
+
+static void gst_soup_http_client_sink_set_property (GObject * object,
+    guint property_id, const GValue * value, GParamSpec * pspec);
+static void gst_soup_http_client_sink_get_property (GObject * object,
+    guint property_id, GValue * value, GParamSpec * pspec);
+static void gst_soup_http_client_sink_dispose (GObject * object);
+static void gst_soup_http_client_sink_finalize (GObject * object);
+
+static gboolean gst_soup_http_client_sink_set_caps (GstBaseSink * sink,
+    GstCaps * caps);
+static gboolean gst_soup_http_client_sink_start (GstBaseSink * sink);
+static gboolean gst_soup_http_client_sink_stop (GstBaseSink * sink);
+static gboolean gst_soup_http_client_sink_unlock (GstBaseSink * sink);
+static GstFlowReturn gst_soup_http_client_sink_render (GstBaseSink * sink,
+    GstBuffer * buffer);
+static void gst_soup_http_client_sink_reset (GstSoupHttpClientSink *
+    souphttpsink);
+
+static gboolean authenticate (SoupMessage * msg, SoupAuth * auth,
+    gboolean retrying, gpointer user_data);
+static void restarted (SoupMessage * msg, GBytes * body);
+static gboolean send_handle_status (SoupMessage * msg, GError * error,
+    GstSoupHttpClientSink * sink);
+
+static gboolean
+gst_soup_http_client_sink_set_proxy (GstSoupHttpClientSink * souphttpsink,
+    const gchar * uri);
+
+enum
+{
+  PROP_0,
+  PROP_LOCATION,
+  PROP_USER_AGENT,
+  PROP_AUTOMATIC_REDIRECT,
+  PROP_PROXY,
+  PROP_USER_ID,
+  PROP_USER_PW,
+  PROP_PROXY_ID,
+  PROP_PROXY_PW,
+  PROP_COOKIES,
+  PROP_SESSION,
+  PROP_SOUP_LOG_LEVEL,
+  PROP_RETRY_DELAY,
+  PROP_RETRIES
+};
+
+#define DEFAULT_USER_AGENT           "GStreamer souphttpclientsink "
+#define DEFAULT_SOUP_LOG_LEVEL       SOUP_LOGGER_LOG_NONE
+
+/* pad templates */
+
+static GstStaticPadTemplate gst_soup_http_client_sink_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+
+/* class initialization */
+
+#define gst_soup_http_client_sink_parent_class parent_class
+G_DEFINE_TYPE (GstSoupHttpClientSink, gst_soup_http_client_sink,
+    GST_TYPE_BASE_SINK);
+
+static gboolean souphttpclientsink_element_init (GstPlugin * plugin);
+GST_ELEMENT_REGISTER_DEFINE_CUSTOM (souphttpclientsink,
+    souphttpclientsink_element_init);
+
+
+static void
+gst_soup_http_client_sink_class_init (GstSoupHttpClientSinkClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
+  GstBaseSinkClass *base_sink_class = GST_BASE_SINK_CLASS (klass);
+
+  gobject_class->set_property = gst_soup_http_client_sink_set_property;
+  gobject_class->get_property = gst_soup_http_client_sink_get_property;
+  gobject_class->dispose = gst_soup_http_client_sink_dispose;
+  gobject_class->finalize = gst_soup_http_client_sink_finalize;
+
+  g_object_class_install_property (gobject_class,
+      PROP_LOCATION,
+      g_param_spec_string ("location", "Location",
+          "URI to send to", "", G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class,
+      PROP_USER_AGENT,
+      g_param_spec_string ("user-agent", "User-Agent",
+          "Value of the User-Agent HTTP request header field",
+          DEFAULT_USER_AGENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class,
+      PROP_AUTOMATIC_REDIRECT,
+      g_param_spec_boolean ("automatic-redirect", "automatic-redirect",
+          "Automatically follow HTTP redirects (HTTP Status Code 3xx)",
+          TRUE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class,
+      PROP_PROXY,
+      g_param_spec_string ("proxy", "Proxy",
+          "HTTP proxy server URI", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class,
+      PROP_USER_ID,
+      g_param_spec_string ("user-id", "user-id",
+          "user id for authentication", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_USER_PW,
+      g_param_spec_string ("user-pw", "user-pw",
+          "user password for authentication", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_PROXY_ID,
+      g_param_spec_string ("proxy-id", "proxy-id",
+          "user id for proxy authentication", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_PROXY_PW,
+      g_param_spec_string ("proxy-pw", "proxy-pw",
+          "user password for proxy authentication", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_SESSION,
+      g_param_spec_object ("session", "session",
+          "SoupSession object to use for communication",
+          _soup_session_get_type (),
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_COOKIES,
+      g_param_spec_boxed ("cookies", "Cookies", "HTTP request cookies",
+          G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_RETRY_DELAY,
+      g_param_spec_int ("retry-delay", "Retry Delay",
+          "Delay in seconds between retries after a failure", 1, G_MAXINT, 5,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_RETRIES,
+      g_param_spec_int ("retries", "Retries",
+          "Maximum number of retries, zero to disable, -1 to retry forever",
+          -1, G_MAXINT, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+ /**
+   * GstSoupHttpClientSink::http-log-level:
+   *
+   * If set and > 0, captures and dumps HTTP session data as
+   * log messages if log level >= GST_LEVEL_TRACE
+   *
+   * Since: 1.4
+   */
+  g_object_class_install_property (gobject_class, PROP_SOUP_LOG_LEVEL,
+      g_param_spec_enum ("http-log-level", "HTTP log level",
+          "Set log level for soup's HTTP session log",
+          _soup_logger_log_level_get_type (),
+          DEFAULT_SOUP_LOG_LEVEL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &gst_soup_http_client_sink_sink_template);
+
+  gst_element_class_set_static_metadata (gstelement_class, "HTTP client sink",
+      "Generic", "Sends streams to HTTP server via PUT",
+      "David Schleef <ds@entropywave.com>");
+
+  base_sink_class->set_caps =
+      GST_DEBUG_FUNCPTR (gst_soup_http_client_sink_set_caps);
+  base_sink_class->start = GST_DEBUG_FUNCPTR (gst_soup_http_client_sink_start);
+  base_sink_class->stop = GST_DEBUG_FUNCPTR (gst_soup_http_client_sink_stop);
+  base_sink_class->unlock =
+      GST_DEBUG_FUNCPTR (gst_soup_http_client_sink_unlock);
+  base_sink_class->render =
+      GST_DEBUG_FUNCPTR (gst_soup_http_client_sink_render);
+}
+
+static void
+gst_soup_http_client_sink_init (GstSoupHttpClientSink * souphttpsink)
+{
+  const char *proxy;
+
+  g_mutex_init (&souphttpsink->mutex);
+  g_cond_init (&souphttpsink->cond);
+
+  souphttpsink->location = NULL;
+  souphttpsink->automatic_redirect = TRUE;
+  souphttpsink->user_agent = g_strdup (DEFAULT_USER_AGENT);
+  souphttpsink->user_id = NULL;
+  souphttpsink->user_pw = NULL;
+  souphttpsink->proxy_id = NULL;
+  souphttpsink->proxy_pw = NULL;
+  souphttpsink->prop_session = NULL;
+  souphttpsink->timeout = 1;
+  souphttpsink->log_level = DEFAULT_SOUP_LOG_LEVEL;
+  souphttpsink->retry_delay = 5;
+  souphttpsink->retries = 0;
+  souphttpsink->sent_buffers = NULL;
+  proxy = g_getenv ("http_proxy");
+  if (proxy && !gst_soup_http_client_sink_set_proxy (souphttpsink, proxy)) {
+    GST_WARNING_OBJECT (souphttpsink,
+        "The proxy in the http_proxy env var (\"%s\") cannot be parsed.",
+        proxy);
+  }
+
+  gst_soup_http_client_sink_reset (souphttpsink);
+}
+
+static void
+gst_soup_http_client_sink_reset (GstSoupHttpClientSink * souphttpsink)
+{
+  g_list_free_full (souphttpsink->queued_buffers,
+      (GDestroyNotify) gst_buffer_unref);
+  souphttpsink->queued_buffers = NULL;
+  g_free (souphttpsink->reason_phrase);
+  souphttpsink->reason_phrase = NULL;
+  souphttpsink->status_code = 0;
+  souphttpsink->offset = 0;
+  souphttpsink->failures = 0;
+
+  g_list_free_full (souphttpsink->streamheader_buffers,
+      (GDestroyNotify) gst_buffer_unref);
+  souphttpsink->streamheader_buffers = NULL;
+  g_list_free_full (souphttpsink->sent_buffers,
+      (GDestroyNotify) gst_buffer_unref);
+  souphttpsink->sent_buffers = NULL;
+}
+
+static gboolean
+gst_soup_http_client_sink_set_proxy (GstSoupHttpClientSink * souphttpsink,
+    const gchar * uri)
+{
+  if (souphttpsink->proxy) {
+    gst_soup_uri_free (souphttpsink->proxy);
+    souphttpsink->proxy = NULL;
+  }
+  if (g_str_has_prefix (uri, "http://")) {
+    souphttpsink->proxy = gst_soup_uri_new (uri);
+  } else {
+    gchar *new_uri = g_strconcat ("http://", uri, NULL);
+
+    souphttpsink->proxy = gst_soup_uri_new (new_uri);
+    g_free (new_uri);
+  }
+
+  return TRUE;
+}
+
+void
+gst_soup_http_client_sink_set_property (GObject * object, guint property_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (object);
+
+  g_mutex_lock (&souphttpsink->mutex);
+  switch (property_id) {
+    case PROP_SESSION:
+      if (souphttpsink->prop_session) {
+        g_object_unref (souphttpsink->prop_session);
+      }
+      souphttpsink->prop_session = g_value_dup_object (value);
+      break;
+    case PROP_LOCATION:
+      g_free (souphttpsink->location);
+      souphttpsink->location = g_value_dup_string (value);
+      souphttpsink->offset = 0;
+      if ((souphttpsink->location == NULL)
+          || !gst_uri_is_valid (souphttpsink->location)) {
+        GST_WARNING_OBJECT (souphttpsink,
+            "The location (\"%s\") set, is not a valid uri.",
+            souphttpsink->location);
+        g_free (souphttpsink->location);
+        souphttpsink->location = NULL;
+      }
+      break;
+    case PROP_USER_AGENT:
+      g_free (souphttpsink->user_agent);
+      souphttpsink->user_agent = g_value_dup_string (value);
+      break;
+    case PROP_AUTOMATIC_REDIRECT:
+      souphttpsink->automatic_redirect = g_value_get_boolean (value);
+      break;
+    case PROP_USER_ID:
+      g_free (souphttpsink->user_id);
+      souphttpsink->user_id = g_value_dup_string (value);
+      break;
+    case PROP_USER_PW:
+      g_free (souphttpsink->user_pw);
+      souphttpsink->user_pw = g_value_dup_string (value);
+      break;
+    case PROP_PROXY_ID:
+      g_free (souphttpsink->proxy_id);
+      souphttpsink->proxy_id = g_value_dup_string (value);
+      break;
+    case PROP_PROXY_PW:
+      g_free (souphttpsink->proxy_pw);
+      souphttpsink->proxy_pw = g_value_dup_string (value);
+      break;
+    case PROP_PROXY:
+    {
+      const gchar *proxy;
+
+      proxy = g_value_get_string (value);
+
+      if (proxy == NULL) {
+        GST_WARNING ("proxy property cannot be NULL");
+        goto done;
+      }
+      if (!gst_soup_http_client_sink_set_proxy (souphttpsink, proxy)) {
+        GST_WARNING ("badly formatted proxy URI");
+        goto done;
+      }
+      break;
+    }
+    case PROP_COOKIES:
+      g_strfreev (souphttpsink->cookies);
+      souphttpsink->cookies = g_strdupv (g_value_get_boxed (value));
+      break;
+    case PROP_SOUP_LOG_LEVEL:
+      souphttpsink->log_level = g_value_get_enum (value);
+      break;
+    case PROP_RETRY_DELAY:
+      souphttpsink->retry_delay = g_value_get_int (value);
+      break;
+    case PROP_RETRIES:
+      souphttpsink->retries = g_value_get_int (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+done:
+  g_mutex_unlock (&souphttpsink->mutex);
+}
+
+void
+gst_soup_http_client_sink_get_property (GObject * object, guint property_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (object);
+
+  switch (property_id) {
+    case PROP_SESSION:
+      g_value_set_object (value, souphttpsink->prop_session);
+      break;
+    case PROP_LOCATION:
+      g_value_set_string (value, souphttpsink->location);
+      break;
+    case PROP_AUTOMATIC_REDIRECT:
+      g_value_set_boolean (value, souphttpsink->automatic_redirect);
+      break;
+    case PROP_USER_AGENT:
+      g_value_set_string (value, souphttpsink->user_agent);
+      break;
+    case PROP_USER_ID:
+      g_value_set_string (value, souphttpsink->user_id);
+      break;
+    case PROP_USER_PW:
+      g_value_set_string (value, souphttpsink->user_pw);
+      break;
+    case PROP_PROXY_ID:
+      g_value_set_string (value, souphttpsink->proxy_id);
+      break;
+    case PROP_PROXY_PW:
+      g_value_set_string (value, souphttpsink->proxy_pw);
+      break;
+    case PROP_PROXY:
+      if (souphttpsink->proxy == NULL)
+        g_value_set_static_string (value, "");
+      else {
+        char *proxy = gst_soup_uri_to_string (souphttpsink->proxy);
+
+        g_value_set_string (value, proxy);
+        g_free (proxy);
+      }
+      break;
+    case PROP_COOKIES:
+      g_value_set_boxed (value, g_strdupv (souphttpsink->cookies));
+      break;
+    case PROP_SOUP_LOG_LEVEL:
+      g_value_set_enum (value, souphttpsink->log_level);
+      break;
+    case PROP_RETRY_DELAY:
+      g_value_set_int (value, souphttpsink->retry_delay);
+      break;
+    case PROP_RETRIES:
+      g_value_set_int (value, souphttpsink->retries);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+      break;
+  }
+}
+
+void
+gst_soup_http_client_sink_dispose (GObject * object)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (object);
+
+  /* clean up as possible.  may be called multiple times */
+  if (souphttpsink->prop_session)
+    g_object_unref (souphttpsink->prop_session);
+  souphttpsink->prop_session = NULL;
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+void
+gst_soup_http_client_sink_finalize (GObject * object)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (object);
+
+  /* clean up object here */
+
+  g_free (souphttpsink->user_agent);
+  g_free (souphttpsink->user_id);
+  g_free (souphttpsink->user_pw);
+  g_free (souphttpsink->proxy_id);
+  g_free (souphttpsink->proxy_pw);
+  if (souphttpsink->proxy)
+    gst_soup_uri_free (souphttpsink->proxy);
+  g_free (souphttpsink->location);
+  g_strfreev (souphttpsink->cookies);
+
+  g_cond_clear (&souphttpsink->cond);
+  g_mutex_clear (&souphttpsink->mutex);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_soup_http_client_sink_set_caps (GstBaseSink * sink, GstCaps * caps)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (sink);
+  GstStructure *structure;
+  const GValue *value_array;
+  int i, n;
+
+  GST_DEBUG_OBJECT (souphttpsink, "new stream headers set");
+  structure = gst_caps_get_structure (caps, 0);
+  value_array = gst_structure_get_value (structure, "streamheader");
+  if (value_array) {
+    g_list_free_full (souphttpsink->streamheader_buffers,
+        (GDestroyNotify) gst_buffer_unref);
+    souphttpsink->streamheader_buffers = NULL;
+
+    n = gst_value_array_get_size (value_array);
+    for (i = 0; i < n; i++) {
+      const GValue *value;
+      GstBuffer *buffer;
+      value = gst_value_array_get_value (value_array, i);
+      buffer = GST_BUFFER (gst_value_get_buffer (value));
+      souphttpsink->streamheader_buffers =
+          g_list_append (souphttpsink->streamheader_buffers,
+          gst_buffer_ref (buffer));
+    }
+  }
+
+  return TRUE;
+}
+
+static gboolean
+thread_ready_idle_cb (gpointer data)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (data);
+
+  GST_LOG_OBJECT (souphttpsink, "thread ready");
+
+  g_mutex_lock (&souphttpsink->mutex);
+  g_cond_signal (&souphttpsink->cond);
+  g_mutex_unlock (&souphttpsink->mutex);
+
+  return FALSE;                 /* only run once */
+}
+
+static gpointer
+thread_func (gpointer ptr)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (ptr);
+  GProxyResolver *proxy_resolver;
+  GMainContext *context;
+
+  GST_DEBUG ("thread start");
+
+  context = souphttpsink->context;
+  g_main_context_push_thread_default (context);
+
+  if (souphttpsink->proxy != NULL) {
+    char *proxy_string = gst_soup_uri_to_string (souphttpsink->proxy);
+    proxy_resolver = g_simple_proxy_resolver_new (proxy_string, NULL);
+    g_free (proxy_string);
+  } else
+    proxy_resolver = g_object_ref (g_proxy_resolver_get_default ());
+
+  souphttpsink->session =
+      _soup_session_new_with_options ("user-agent", souphttpsink->user_agent,
+      "timeout", souphttpsink->timeout, "proxy-resolver", proxy_resolver, NULL);
+
+  g_object_unref (proxy_resolver);
+
+  if (gst_soup_loader_get_api_version () < 3) {
+    g_signal_connect (souphttpsink->session, "authenticate",
+        G_CALLBACK (authenticate), souphttpsink);
+  }
+
+  GST_DEBUG ("created session");
+
+  g_main_loop_run (souphttpsink->loop);
+
+  g_main_context_pop_thread_default (context);
+
+  GST_DEBUG ("thread quit");
+
+  return NULL;
+}
+
+static gboolean
+gst_soup_http_client_sink_start (GstBaseSink * sink)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (sink);
+
+  if (souphttpsink->prop_session) {
+    souphttpsink->session = souphttpsink->prop_session;
+  } else {
+    GSource *source;
+    GError *error = NULL;
+
+    souphttpsink->context = g_main_context_new ();
+
+    /* set up idle source to signal when the main loop is running and
+     * it's safe for ::stop() to call g_main_loop_quit() */
+    source = g_idle_source_new ();
+    g_source_set_callback (source, thread_ready_idle_cb, sink, NULL);
+    g_source_attach (source, souphttpsink->context);
+    g_source_unref (source);
+
+    souphttpsink->loop = g_main_loop_new (souphttpsink->context, FALSE);
+
+    g_mutex_lock (&souphttpsink->mutex);
+
+    souphttpsink->thread = g_thread_try_new ("souphttpclientsink-thread",
+        thread_func, souphttpsink, &error);
+
+    if (error != NULL) {
+      GST_DEBUG_OBJECT (souphttpsink, "failed to start thread, %s",
+          error->message);
+      g_error_free (error);
+      g_mutex_unlock (&souphttpsink->mutex);
+      return FALSE;
+    }
+
+    GST_LOG_OBJECT (souphttpsink, "waiting for main loop thread to start up");
+    while (!g_main_loop_is_running (souphttpsink->loop))
+      g_cond_wait (&souphttpsink->cond, &souphttpsink->mutex);
+    g_mutex_unlock (&souphttpsink->mutex);
+    GST_LOG_OBJECT (souphttpsink, "main loop thread running");
+  }
+
+  /* Set up logging */
+  gst_soup_util_log_setup (souphttpsink->session, souphttpsink->log_level,
+      G_OBJECT (souphttpsink));
+
+  return TRUE;
+}
+
+static gboolean
+gst_soup_http_client_sink_stop (GstBaseSink * sink)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (sink);
+
+  GST_DEBUG ("stop");
+
+  if (souphttpsink->prop_session == NULL) {
+    _soup_session_abort (souphttpsink->session);
+    g_object_unref (souphttpsink->session);
+  }
+
+  g_mutex_lock (&souphttpsink->mutex);
+  if (souphttpsink->timer) {
+    g_source_destroy (souphttpsink->timer);
+    g_source_unref (souphttpsink->timer);
+    souphttpsink->timer = NULL;
+  }
+  g_mutex_unlock (&souphttpsink->mutex);
+
+  if (souphttpsink->loop) {
+    g_main_loop_quit (souphttpsink->loop);
+    g_mutex_lock (&souphttpsink->mutex);
+    g_cond_signal (&souphttpsink->cond);
+    g_mutex_unlock (&souphttpsink->mutex);
+    g_thread_join (souphttpsink->thread);
+    g_main_loop_unref (souphttpsink->loop);
+    souphttpsink->loop = NULL;
+  }
+  if (souphttpsink->context) {
+    g_main_context_unref (souphttpsink->context);
+    souphttpsink->context = NULL;
+  }
+
+  gst_soup_http_client_sink_reset (souphttpsink);
+
+  return TRUE;
+}
+
+static gboolean
+gst_soup_http_client_sink_unlock (GstBaseSink * sink)
+{
+  GST_DEBUG ("unlock");
+
+  return TRUE;
+}
+
+static void
+send_message_locked (GstSoupHttpClientSink * souphttpsink)
+{
+  GList *g;
+  guint64 n;
+  GByteArray *array;
+  GInputStream *in_stream;
+
+  if (souphttpsink->queued_buffers == NULL || souphttpsink->message) {
+    return;
+  }
+
+  /* If the URI went away, drop all these buffers */
+  if (souphttpsink->location == NULL) {
+    GST_DEBUG_OBJECT (souphttpsink, "URI went away, dropping queued buffers");
+    g_list_free_full (souphttpsink->queued_buffers,
+        (GDestroyNotify) gst_buffer_unref);
+    souphttpsink->queued_buffers = NULL;
+    return;
+  }
+
+  souphttpsink->message = _soup_message_new ("PUT", souphttpsink->location);
+  if (souphttpsink->message == NULL) {
+    GST_WARNING_OBJECT (souphttpsink,
+        "URI could not be parsed while creating message.");
+    g_list_free_full (souphttpsink->queued_buffers,
+        (GDestroyNotify) gst_buffer_unref);
+    souphttpsink->queued_buffers = NULL;
+    return;
+  }
+
+  g_signal_connect (souphttpsink->message, "restarted", G_CALLBACK (restarted),
+      souphttpsink->request_body);
+
+  _soup_message_set_flags (souphttpsink->message,
+      (souphttpsink->automatic_redirect ? 0 : SOUP_MESSAGE_NO_REDIRECT));
+
+  if (souphttpsink->cookies) {
+    gchar **cookie;
+
+    for (cookie = souphttpsink->cookies; *cookie != NULL; cookie++) {
+      _soup_message_headers_append (_soup_message_get_request_headers
+          (souphttpsink->message), "Cookie", *cookie);
+    }
+  }
+  array = g_byte_array_new ();
+  n = 0;
+  if (souphttpsink->offset == 0) {
+    for (g = souphttpsink->streamheader_buffers; g; g = g_list_next (g)) {
+      GstBuffer *buffer = g->data;
+      GstMapInfo map;
+
+      GST_DEBUG_OBJECT (souphttpsink, "queueing stream headers");
+      gst_buffer_map (buffer, &map, GST_MAP_READ);
+      g_byte_array_append (array, map.data, map.size);
+      n += map.size;
+      gst_buffer_unmap (buffer, &map);
+    }
+  }
+
+  for (g = souphttpsink->queued_buffers; g; g = g_list_next (g)) {
+    GstBuffer *buffer = g->data;
+    if (!GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_HEADER)) {
+      GstMapInfo map;
+
+      gst_buffer_map (buffer, &map, GST_MAP_READ);
+      g_byte_array_append (array, map.data, map.size);
+      n += map.size;
+      gst_buffer_unmap (buffer, &map);
+    }
+  }
+
+  {
+    souphttpsink->request_body = g_byte_array_free_to_bytes (array);
+    _soup_message_set_request_body_from_bytes (souphttpsink->message,
+        NULL, souphttpsink->request_body);
+  }
+
+  if (souphttpsink->offset != 0) {
+    char *s;
+    s = g_strdup_printf ("bytes %" G_GUINT64_FORMAT "-%" G_GUINT64_FORMAT "/*",
+        souphttpsink->offset, souphttpsink->offset + n - 1);
+    _soup_message_headers_append (_soup_message_get_request_headers
+        (souphttpsink->message), "Content-Range", s);
+    g_free (s);
+  }
+
+  if (n == 0) {
+    GST_DEBUG_OBJECT (souphttpsink,
+        "total size of buffers queued is 0, freeing everything");
+    g_list_free_full (souphttpsink->queued_buffers,
+        (GDestroyNotify) gst_buffer_unref);
+    souphttpsink->queued_buffers = NULL;
+    g_clear_object (&souphttpsink->message);
+    g_clear_pointer (&souphttpsink->request_body, g_bytes_unref);
+    return;
+  }
+
+  in_stream =
+      _soup_session_send (souphttpsink->session, souphttpsink->message, NULL,
+      NULL);
+  if (in_stream == NULL) {
+    GError *error = NULL;
+
+    if (!send_handle_status (souphttpsink->message, error, souphttpsink)) {
+      g_object_unref (souphttpsink->message);
+      g_clear_pointer (&souphttpsink->request_body, g_bytes_unref);
+      g_clear_error (&error);
+      return;
+    }
+  }
+  souphttpsink->sent_buffers = souphttpsink->queued_buffers;
+
+  g_clear_pointer (&souphttpsink->request_body, g_bytes_unref);
+  g_object_unref (in_stream);
+
+  g_list_free_full (souphttpsink->sent_buffers,
+      (GDestroyNotify) gst_buffer_unref);
+  souphttpsink->sent_buffers = NULL;
+  souphttpsink->failures = 0;
+  souphttpsink->queued_buffers = NULL;
+  g_clear_object (&souphttpsink->message);
+  souphttpsink->offset += n;
+}
+
+static gboolean
+send_message (GstSoupHttpClientSink * souphttpsink)
+{
+  g_mutex_lock (&souphttpsink->mutex);
+  send_message_locked (souphttpsink);
+  if (souphttpsink->timer) {
+    g_source_destroy (souphttpsink->timer);
+    g_source_unref (souphttpsink->timer);
+    souphttpsink->timer = NULL;
+  }
+  g_mutex_unlock (&souphttpsink->mutex);
+
+  return FALSE;
+}
+
+static gboolean
+send_handle_status (SoupMessage * msg, GError * error,
+    GstSoupHttpClientSink * sink)
+{
+  if (error) {
+    GST_DEBUG_OBJECT (sink, "callback error=%d %s",
+        error->code, error->message);
+  } else {
+    GST_DEBUG_OBJECT (sink, "callback status=%d %s",
+        _soup_message_get_status (msg), _soup_message_get_reason_phrase (msg));
+  }
+
+  if (error || !SOUP_STATUS_IS_SUCCESSFUL (_soup_message_get_status (msg))) {
+    sink->failures++;
+    if (sink->retries && (sink->retries < 0 || sink->retries >= sink->failures)) {
+      guint64 retry_delay;
+      const char *retry_after;
+      SoupMessageHeaders *res_hdrs;
+      if (error) {
+        retry_delay = sink->retry_delay;
+        GST_WARNING_OBJECT (sink, "Could not write to HTTP URI: "
+            "error: %d %s (retrying PUT after %" G_GINT64_FORMAT
+            " seconds)", error->code, error->message, retry_delay);
+        goto err_done;
+      }
+      res_hdrs = _soup_message_get_response_headers (msg);
+      retry_after = _soup_message_headers_get_one (res_hdrs, "Retry-After");
+      if (retry_after) {
+        gchar *end = NULL;
+        retry_delay = g_ascii_strtoull (retry_after, &end, 10);
+        if (end || errno) {
+          retry_delay = sink->retry_delay;
+        } else {
+          retry_delay = MAX (retry_delay, sink->retry_delay);
+        }
+        GST_WARNING_OBJECT (sink, "Could not write to HTTP URI: "
+            "status: %d %s (retrying PUT after %" G_GINT64_FORMAT
+            " seconds with Retry-After: %s)",
+            _soup_message_get_status (msg),
+            _soup_message_get_reason_phrase (msg), retry_delay, retry_after);
+      } else {
+        retry_delay = sink->retry_delay;
+        GST_WARNING_OBJECT (sink, "Could not write to HTTP URI: "
+            "status: %d %s (retrying PUT after %" G_GINT64_FORMAT
+            " seconds)",
+            _soup_message_get_status (msg),
+            _soup_message_get_reason_phrase (msg), retry_delay);
+      }
+    err_done:
+      sink->timer = g_timeout_source_new_seconds (retry_delay);
+      g_source_set_callback (sink->timer, (GSourceFunc) (send_message),
+          sink, NULL);
+      g_source_attach (sink->timer, sink->context);
+    } else {
+      sink->status_code = _soup_message_get_status (msg);
+      sink->reason_phrase = g_strdup (_soup_message_get_reason_phrase (msg));
+    }
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_soup_http_client_sink_render (GstBaseSink * sink, GstBuffer * buffer)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (sink);
+  GSource *source;
+
+  if (souphttpsink->status_code != 0) {
+    GST_ELEMENT_ERROR (souphttpsink, RESOURCE, WRITE,
+        ("Could not write to HTTP URI"),
+        ("status: %d %s", souphttpsink->status_code,
+            souphttpsink->reason_phrase));
+    return GST_FLOW_ERROR;
+  }
+
+  g_mutex_lock (&souphttpsink->mutex);
+  if (souphttpsink->location != NULL) {
+    souphttpsink->queued_buffers =
+        g_list_append (souphttpsink->queued_buffers, gst_buffer_ref (buffer));
+
+    GST_DEBUG_OBJECT (souphttpsink, "setting callback for new buffers");
+    source = g_idle_source_new ();
+    g_source_set_callback (source, (GSourceFunc) (send_message),
+        souphttpsink, NULL);
+    g_source_attach (source, souphttpsink->context);
+    g_source_unref (source);
+  }
+  g_mutex_unlock (&souphttpsink->mutex);
+
+  return GST_FLOW_OK;
+}
+
+static void
+restarted (SoupMessage * msg, GBytes * body)
+{
+  _soup_message_set_request_body_from_bytes (msg, NULL, body);
+}
+
+static gboolean
+authenticate (SoupMessage * msg, SoupAuth * auth,
+    gboolean retrying, gpointer user_data)
+{
+  GstSoupHttpClientSink *souphttpsink = GST_SOUP_HTTP_CLIENT_SINK (user_data);
+
+  if (!retrying) {
+    SoupStatus status_code = _soup_message_get_status (msg);
+    /* First time authentication only, if we fail and are called again with retry true fall through */
+    if (status_code == SOUP_STATUS_UNAUTHORIZED) {
+      if (souphttpsink->user_id && souphttpsink->user_pw)
+        _soup_auth_authenticate (auth, souphttpsink->user_id,
+            souphttpsink->user_pw);
+    } else if (status_code == SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED) {
+      if (souphttpsink->proxy_id && souphttpsink->proxy_pw)
+        _soup_auth_authenticate (auth, souphttpsink->proxy_id,
+            souphttpsink->proxy_pw);
+    }
+  }
+  return FALSE;
+}
+
+static gboolean
+souphttpclientsink_element_init (GstPlugin * plugin)
+{
+  gboolean ret = TRUE;
+
+  GST_DEBUG_CATEGORY_INIT (souphttpclientsink_dbg, "souphttpclientsink", 0,
+      "souphttpclientsink element");
+
+  if (!soup_element_init (plugin))
+    return TRUE;
+
+  ret =
+      gst_element_register (plugin, "souphttpclientsink", GST_RANK_NONE,
+      GST_TYPE_SOUP_HTTP_CLIENT_SINK);
+
+  return ret;
+}
diff --git a/ext/soup3/gstsouphttpclientsink.h b/ext/soup3/gstsouphttpclientsink.h
new file mode 100644
index 0000000..24faca9
--- /dev/null
+++ b/ext/soup3/gstsouphttpclientsink.h
@@ -0,0 +1,76 @@
+/* GStreamer
+ * Copyright (C) 2011 David Schleef <ds@entropywave.com>
+ * Copyright (C) 2021 Igalia S.L.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _GST_SOUP_HTTP_CLIENT_SINK_H_
+#define _GST_SOUP_HTTP_CLIENT_SINK_H_
+
+#include "gstsouploader.h"
+#include "gstsouputils.h"
+#include <gst/base/gstbasesink.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_SOUP_HTTP_CLIENT_SINK (gst_soup_http_client_sink_get_type())
+G_DECLARE_FINAL_TYPE (GstSoupHttpClientSink, gst_soup_http_client_sink,
+    GST, SOUP_HTTP_CLIENT_SINK, GstBaseSink)
+
+struct _GstSoupHttpClientSink
+{
+  GstBaseSink base_souphttpsink;
+
+  GMutex mutex;
+  GCond cond;
+  GMainContext *context;
+  GMainLoop *loop;
+  GThread *thread;
+  GSource *timer;
+  SoupMessage *message;
+  SoupSession *session;
+  GList *queued_buffers;
+  GList *sent_buffers;
+  GList *streamheader_buffers;
+  GBytes *request_body;
+
+  int status_code;
+  char *reason_phrase;
+
+  guint64 offset;
+  int timeout;
+  gint failures;
+
+  /* properties */
+  SoupSession *prop_session;
+  char *location;
+  char *user_id;
+  char *user_pw;
+  GstSoupUri *proxy;
+  char *proxy_id;
+  char *proxy_pw;
+  char *user_agent;
+  gboolean automatic_redirect;
+  gchar **cookies;
+  SoupLoggerLogLevel log_level;
+  gint retry_delay;
+  gint retries;
+};
+
+G_END_DECLS
+
+#endif
diff --git a/ext/soup3/gstsouphttpsrc.c b/ext/soup3/gstsouphttpsrc.c
new file mode 100644
index 0000000..4148003
--- /dev/null
+++ b/ext/soup3/gstsouphttpsrc.c
@@ -0,0 +1,2656 @@
+/* GStreamer
+ * Copyright (C) 2007-2008 Wouter Cloetens <wouter@mind.be>
+ * Copyright (C) 2021 Igalia S.L.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+/**
+ * SECTION:element-souphttpsrc
+ * @title: souphttpsrc
+ *
+ * This plugin reads data from a remote location specified by a URI.
+ * Supported protocols are 'http', 'https'.
+ *
+ * An HTTP proxy must be specified by its URL.
+ * If the "http_proxy" environment variable is set, its value is used.
+ * If built with libsoup's GNOME integration features, the GNOME proxy
+ * configuration will be used, or failing that, proxy autodetection.
+ * The #GstSoupHTTPSrc:proxy property can be used to override the default.
+ *
+ * In case the #GstSoupHTTPSrc:iradio-mode property is set and the location is
+ * an HTTP resource, souphttpsrc will send special Icecast HTTP headers to the
+ * server to request additional Icecast meta-information.
+ * If the server is not an Icecast server, it will behave as if the
+ * #GstSoupHTTPSrc:iradio-mode property were not set. If it is, souphttpsrc will
+ * output data with a media type of application/x-icy, in which case you will
+ * need to use the #GstICYDemux element as follow-up element to extract the Icecast
+ * metadata and to determine the underlying media type.
+ *
+ * ## Example launch line
+ * |[
+ * gst-launch-1.0 -v souphttpsrc location=https://some.server.org/index.html
+ *     ! filesink location=/home/joe/server.html
+ * ]| The above pipeline reads a web page from a server using the HTTPS protocol
+ * and writes it to a local file.
+ * |[
+ * gst-launch-1.0 -v souphttpsrc user-agent="FooPlayer 0.99 beta"
+ *     automatic-redirect=false proxy=http://proxy.intranet.local:8080
+ *     location=http://music.foobar.com/demo.mp3 ! mpgaudioparse
+ *     ! mpg123audiodec ! audioconvert ! audioresample ! autoaudiosink
+ * ]| The above pipeline will read and decode and play an mp3 file from a
+ * web server using the HTTP protocol. If the server sends redirects,
+ * the request fails instead of following the redirect. The specified
+ * HTTP proxy server is used. The User-Agent HTTP request header
+ * is set to a custom string instead of "GStreamer souphttpsrc."
+ * |[
+ * gst-launch-1.0 -v souphttpsrc location=http://10.11.12.13/mjpeg
+ *     do-timestamp=true ! multipartdemux
+ *     ! image/jpeg,width=640,height=480 ! matroskamux
+ *     ! filesink location=mjpeg.mkv
+ * ]| The above pipeline reads a motion JPEG stream from an IP camera
+ * using the HTTP protocol, encoded as mime/multipart image/jpeg
+ * parts, and writes a Matroska motion JPEG file. The width and
+ * height properties are set in the caps to provide the Matroska
+ * multiplexer with the information to set this in the header.
+ * Timestamps are set on the buffers as they arrive from the camera.
+ * These are used by the mime/multipart demultiplexer to emit timestamps
+ * on the JPEG-encoded video frame buffers. This allows the Matroska
+ * multiplexer to timestamp the frames in the resulting file.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>             /* atoi() */
+#endif
+#include <gst/gstelement.h>
+#include <glib/gi18n-lib.h>
+#include "gstsoupelements.h"
+#include "gstsouphttpsrc.h"
+#include "gstsouputils.h"
+
+#include <gst/tag/tag.h>
+
+#define GST_ELEMENT_REGISTER_DEFINE_CUSTOM(element, register_func) \
+G_BEGIN_DECLS \
+gboolean G_PASTE (gst_element_register_, element) (GstPlugin * plugin) \
+{ \
+  return register_func (plugin); \
+} \
+G_END_DECLS
+
+/* this is a simple wrapper class around SoupSession; it exists in order to
+ * have a refcountable owner for the actual SoupSession + the thread it runs
+ * in and its main loop (we cannot inverse the ownership hierarchy, because
+ * the thread + loop are actually longer lived than the session)
+ *
+ * it is entirely private to this implementation
+ */
+
+#define GST_TYPE_SOUP_SESSION (gst_soup_session_get_type())
+#define GST_SOUP_SESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SOUP_SESSION, GstSoupSession))
+
+GType gst_soup_session_get_type (void);
+
+typedef struct _GstSoupSessionClass GstSoupSessionClass;
+
+struct _GstSoupSession
+{
+  GObject parent_instance;
+
+  SoupSession *session;
+  GThread *thread;
+  GMainLoop *loop;
+};
+
+struct _GstSoupSessionClass
+{
+  GObjectClass parent_class;
+};
+
+G_DEFINE_TYPE (GstSoupSession, gst_soup_session, G_TYPE_OBJECT);
+
+static void
+gst_soup_session_init (GstSoupSession * sess)
+{
+}
+
+static gboolean
+_soup_session_finalize_cb (gpointer user_data)
+{
+  GstSoupSession *sess = user_data;
+
+  g_main_loop_quit (sess->loop);
+
+  return FALSE;
+}
+
+static void
+gst_soup_session_finalize (GObject * obj)
+{
+  GstSoupSession *sess = GST_SOUP_SESSION (obj);
+  GSource *src;
+
+  /* handle disposing of failure cases */
+  if (!sess->loop)
+    return;
+
+  src = g_idle_source_new ();
+
+  g_source_set_callback (src, _soup_session_finalize_cb, sess, NULL);
+  g_source_attach (src, g_main_loop_get_context (sess->loop));
+  g_source_unref (src);
+
+  /* finish off thread and the loop; ensure it's not from the thread */
+  g_assert (!g_main_context_is_owner (g_main_loop_get_context (sess->loop)));
+  g_thread_join (sess->thread);
+  g_main_loop_unref (sess->loop);
+}
+
+static void
+gst_soup_session_class_init (GstSoupSessionClass * klass)
+{
+  GObjectClass *gclass = G_OBJECT_CLASS (klass);
+
+  gclass->finalize = gst_soup_session_finalize;
+}
+
+GST_DEBUG_CATEGORY_STATIC (souphttpsrc_debug);
+#define GST_CAT_DEFAULT souphttpsrc_debug
+
+#define GST_SOUP_SESSION_CONTEXT "gst.soup.session"
+
+static GstStaticPadTemplate srctemplate = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+enum
+{
+  PROP_0,
+  PROP_LOCATION,
+  PROP_IS_LIVE,
+  PROP_USER_AGENT,
+  PROP_AUTOMATIC_REDIRECT,
+  PROP_PROXY,
+  PROP_USER_ID,
+  PROP_USER_PW,
+  PROP_PROXY_ID,
+  PROP_PROXY_PW,
+  PROP_COOKIES,
+  PROP_IRADIO_MODE,
+  PROP_TIMEOUT,
+  PROP_EXTRA_HEADERS,
+  PROP_SOUP_LOG_LEVEL,
+  PROP_COMPRESS,
+  PROP_KEEP_ALIVE,
+  PROP_SSL_STRICT,
+  PROP_SSL_CA_FILE,
+  PROP_SSL_USE_SYSTEM_CA_FILE,
+  PROP_TLS_DATABASE,
+  PROP_RETRIES,
+  PROP_METHOD,
+  PROP_TLS_INTERACTION,
+};
+
+#define DEFAULT_USER_AGENT           "GStreamer souphttpsrc " PACKAGE_VERSION " "
+#define DEFAULT_IRADIO_MODE          TRUE
+#define DEFAULT_SOUP_LOG_LEVEL       SOUP_LOGGER_LOG_HEADERS
+#define DEFAULT_COMPRESS             FALSE
+#define DEFAULT_KEEP_ALIVE           TRUE
+#define DEFAULT_SSL_STRICT           TRUE
+#define DEFAULT_SSL_CA_FILE          NULL
+#define DEFAULT_SSL_USE_SYSTEM_CA_FILE TRUE
+#define DEFAULT_TLS_DATABASE         NULL
+#define DEFAULT_TLS_INTERACTION      NULL
+#define DEFAULT_TIMEOUT              15
+#define DEFAULT_RETRIES              3
+#define DEFAULT_SOUP_METHOD          NULL
+
+#define GROW_BLOCKSIZE_LIMIT 1
+#define GROW_BLOCKSIZE_COUNT 1
+#define GROW_BLOCKSIZE_FACTOR 2
+#define REDUCE_BLOCKSIZE_LIMIT 0.20
+#define REDUCE_BLOCKSIZE_COUNT 2
+#define REDUCE_BLOCKSIZE_FACTOR 0.5
+#define GROW_TIME_LIMIT (1 * GST_SECOND)
+
+static void gst_soup_http_src_uri_handler_init (gpointer g_iface,
+    gpointer iface_data);
+static void gst_soup_http_src_finalize (GObject * gobject);
+static void gst_soup_http_src_dispose (GObject * gobject);
+
+static void gst_soup_http_src_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_soup_http_src_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+static GstStateChangeReturn gst_soup_http_src_change_state (GstElement *
+    element, GstStateChange transition);
+static void gst_soup_http_src_set_context (GstElement * element,
+    GstContext * context);
+static GstFlowReturn gst_soup_http_src_create (GstPushSrc * psrc,
+    GstBuffer ** outbuf);
+static gboolean gst_soup_http_src_start (GstBaseSrc * bsrc);
+static gboolean gst_soup_http_src_stop (GstBaseSrc * bsrc);
+static gboolean gst_soup_http_src_get_size (GstBaseSrc * bsrc, guint64 * size);
+static gboolean gst_soup_http_src_is_seekable (GstBaseSrc * bsrc);
+static gboolean gst_soup_http_src_do_seek (GstBaseSrc * bsrc,
+    GstSegment * segment);
+static gboolean gst_soup_http_src_query (GstBaseSrc * bsrc, GstQuery * query);
+static gboolean gst_soup_http_src_unlock (GstBaseSrc * bsrc);
+static gboolean gst_soup_http_src_unlock_stop (GstBaseSrc * bsrc);
+static gboolean gst_soup_http_src_set_location (GstSoupHTTPSrc * src,
+    const gchar * uri, GError ** error);
+static gboolean gst_soup_http_src_set_proxy (GstSoupHTTPSrc * src,
+    const gchar * uri);
+static char *gst_soup_http_src_unicodify (const char *str);
+static gboolean gst_soup_http_src_build_message (GstSoupHTTPSrc * src,
+    const gchar * method);
+static gboolean gst_soup_http_src_add_range_header (GstSoupHTTPSrc * src,
+    guint64 offset, guint64 stop_offset);
+static gboolean gst_soup_http_src_session_open (GstSoupHTTPSrc * src);
+static void gst_soup_http_src_session_close (GstSoupHTTPSrc * src);
+static GstFlowReturn gst_soup_http_src_parse_status (SoupMessage * msg,
+    GstSoupHTTPSrc * src);
+static GstFlowReturn gst_soup_http_src_got_headers (GstSoupHTTPSrc * src,
+    SoupMessage * msg);
+static void gst_soup_http_src_authenticate_cb_2 (SoupSession *,
+    SoupMessage * msg, SoupAuth * auth, gboolean retrying, gpointer);
+static gboolean gst_soup_http_src_authenticate_cb (SoupMessage * msg,
+    SoupAuth * auth, gboolean retrying, gpointer);
+static gboolean gst_soup_http_src_accept_certificate_cb (SoupMessage * msg,
+    GTlsCertificate * tls_certificate, GTlsCertificateFlags tls_errors,
+    gpointer user_data);
+
+#define gst_soup_http_src_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstSoupHTTPSrc, gst_soup_http_src, GST_TYPE_PUSH_SRC,
+    G_IMPLEMENT_INTERFACE (GST_TYPE_URI_HANDLER,
+        gst_soup_http_src_uri_handler_init));
+
+static gboolean souphttpsrc_element_init (GstPlugin * plugin);
+GST_ELEMENT_REGISTER_DEFINE_CUSTOM (souphttpsrc, souphttpsrc_element_init);
+
+static void
+gst_soup_http_src_class_init (GstSoupHTTPSrcClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+  GstBaseSrcClass *gstbasesrc_class;
+  GstPushSrcClass *gstpushsrc_class;
+
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+  gstbasesrc_class = (GstBaseSrcClass *) klass;
+  gstpushsrc_class = (GstPushSrcClass *) klass;
+
+  gobject_class->set_property = gst_soup_http_src_set_property;
+  gobject_class->get_property = gst_soup_http_src_get_property;
+  gobject_class->finalize = gst_soup_http_src_finalize;
+  gobject_class->dispose = gst_soup_http_src_dispose;
+
+  g_object_class_install_property (gobject_class,
+      PROP_LOCATION,
+      g_param_spec_string ("location", "Location",
+          "Location to read from", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class,
+      PROP_USER_AGENT,
+      g_param_spec_string ("user-agent", "User-Agent",
+          "Value of the User-Agent HTTP request header field",
+          DEFAULT_USER_AGENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class,
+      PROP_AUTOMATIC_REDIRECT,
+      g_param_spec_boolean ("automatic-redirect", "automatic-redirect",
+          "Automatically follow HTTP redirects (HTTP Status Code 3xx)",
+          TRUE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class,
+      PROP_PROXY,
+      g_param_spec_string ("proxy", "Proxy",
+          "HTTP proxy server URI", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class,
+      PROP_USER_ID,
+      g_param_spec_string ("user-id", "user-id",
+          "HTTP location URI user id for authentication", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_USER_PW,
+      g_param_spec_string ("user-pw", "user-pw",
+          "HTTP location URI user password for authentication", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_PROXY_ID,
+      g_param_spec_string ("proxy-id", "proxy-id",
+          "HTTP proxy URI user id for authentication", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_PROXY_PW,
+      g_param_spec_string ("proxy-pw", "proxy-pw",
+          "HTTP proxy URI user password for authentication", "",
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_COOKIES,
+      g_param_spec_boxed ("cookies", "Cookies", "HTTP request cookies",
+          G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_IS_LIVE,
+      g_param_spec_boolean ("is-live", "is-live", "Act like a live source",
+          FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_TIMEOUT,
+      g_param_spec_uint ("timeout", "timeout",
+          "Value in seconds to timeout a blocking I/O (0 = No timeout).", 0,
+          3600, DEFAULT_TIMEOUT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_EXTRA_HEADERS,
+      g_param_spec_boxed ("extra-headers", "Extra Headers",
+          "Extra headers to append to the HTTP request",
+          GST_TYPE_STRUCTURE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_IRADIO_MODE,
+      g_param_spec_boolean ("iradio-mode", "iradio-mode",
+          "Enable internet radio mode (ask server to send shoutcast/icecast "
+          "metadata interleaved with the actual stream data)",
+          DEFAULT_IRADIO_MODE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+ /**
+   * GstSoupHTTPSrc::http-log-level:
+   *
+   * If set and > 0, captures and dumps HTTP session data as
+   * log messages if log level >= GST_LEVEL_TRACE
+   *
+   * Since: 1.4
+   */
+  g_object_class_install_property (gobject_class, PROP_SOUP_LOG_LEVEL,
+      g_param_spec_enum ("http-log-level", "HTTP log level",
+          "Set log level for soup's HTTP session log",
+          _soup_logger_log_level_get_type (),
+          DEFAULT_SOUP_LOG_LEVEL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstSoupHTTPSrc::compress:
+   *
+   * If set to %TRUE, souphttpsrc will automatically handle gzip
+   * and deflate Content-Encodings. This does not make much difference
+   * and causes more load for normal media files, but makes a real
+   * difference in size for plaintext files.
+   *
+   * Since: 1.4
+   */
+  g_object_class_install_property (gobject_class, PROP_COMPRESS,
+      g_param_spec_boolean ("compress", "Compress",
+          "Allow compressed content encodings",
+          DEFAULT_COMPRESS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+ /**
+   * GstSoupHTTPSrc::keep-alive:
+   *
+   * If set to %TRUE, souphttpsrc will keep alive connections when being
+   * set to READY state and only will close connections when connecting
+   * to a different server or when going to NULL state..
+   *
+   * Since: 1.4
+   */
+  g_object_class_install_property (gobject_class, PROP_KEEP_ALIVE,
+      g_param_spec_boolean ("keep-alive", "keep-alive",
+          "Use HTTP persistent connections", DEFAULT_KEEP_ALIVE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+ /**
+   * GstSoupHTTPSrc::ssl-strict:
+   *
+   * If set to %TRUE, souphttpsrc will reject all SSL certificates that
+   * are considered invalid.
+   *
+   * Since: 1.4
+   */
+  g_object_class_install_property (gobject_class, PROP_SSL_STRICT,
+      g_param_spec_boolean ("ssl-strict", "SSL Strict",
+          "Strict SSL certificate checking", DEFAULT_SSL_STRICT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+ /**
+   * GstSoupHTTPSrc::ssl-ca-file:
+   *
+   * A SSL anchor CA file that should be used for checking certificates
+   * instead of the system CA file.
+   *
+   * If this property is non-%NULL, #GstSoupHTTPSrc::ssl-use-system-ca-file
+   * value will be ignored.
+   *
+   * Deprecated: Use #GstSoupHTTPSrc::tls-database property instead. This
+   * property is no-op when libsoup3 is being used at runtime.
+   *
+   * Since: 1.4
+   */
+  g_object_class_install_property (gobject_class, PROP_SSL_CA_FILE,
+      g_param_spec_string ("ssl-ca-file", "SSL CA File",
+          "Location of a SSL anchor CA file to use", DEFAULT_SSL_CA_FILE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstSoupHTTPSrc::ssl-use-system-ca-file:
+   *
+   * If set to %TRUE, souphttpsrc will use the system's CA file for
+   * checking certificates, unless #GstSoupHTTPSrc::ssl-ca-file or
+   * #GstSoupHTTPSrc::tls-database are non-%NULL.
+   *
+   * Deprecated: This property is no-op when libsoup3 is being used at runtime.
+   *
+   * Since: 1.4
+   */
+  g_object_class_install_property (gobject_class, PROP_SSL_USE_SYSTEM_CA_FILE,
+      g_param_spec_boolean ("ssl-use-system-ca-file", "Use System CA File",
+          "Use system CA file", DEFAULT_SSL_USE_SYSTEM_CA_FILE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstSoupHTTPSrc::tls-database:
+   *
+   * TLS database with anchor certificate authorities used to validate
+   * the server certificate.
+   *
+   * If this property is non-%NULL, #GstSoupHTTPSrc::ssl-use-system-ca-file
+   * and #GstSoupHTTPSrc::ssl-ca-file values will be ignored.
+   *
+   * Since: 1.6
+   */
+  g_object_class_install_property (gobject_class, PROP_TLS_DATABASE,
+      g_param_spec_object ("tls-database", "TLS database",
+          "TLS database with anchor certificate authorities used to validate the server certificate",
+          G_TYPE_TLS_DATABASE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstSoupHTTPSrc::tls-interaction:
+   *
+   * A #GTlsInteraction object to be used when the connection or certificate
+   * database need to interact with the user. This will be used to prompt the
+   * user for passwords or certificate where necessary.
+   *
+   * Since: 1.8
+   */
+  g_object_class_install_property (gobject_class, PROP_TLS_INTERACTION,
+      g_param_spec_object ("tls-interaction", "TLS interaction",
+          "A GTlsInteraction object to be used when the connection or certificate database need to interact with the user.",
+          G_TYPE_TLS_INTERACTION, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+ /**
+   * GstSoupHTTPSrc::retries:
+   *
+   * Maximum number of retries until giving up.
+   *
+   * Since: 1.4
+   */
+  g_object_class_install_property (gobject_class, PROP_RETRIES,
+      g_param_spec_int ("retries", "Retries",
+          "Maximum number of retries until giving up (-1=infinite)", -1,
+          G_MAXINT, DEFAULT_RETRIES,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+ /**
+   * GstSoupHTTPSrc::method
+   *
+   * The HTTP method to use when making a request
+   *
+   * Since: 1.6
+   */
+  g_object_class_install_property (gobject_class, PROP_METHOD,
+      g_param_spec_string ("method", "HTTP method",
+          "The HTTP method to use (GET, HEAD, OPTIONS, etc)",
+          DEFAULT_SOUP_METHOD, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  gst_element_class_add_static_pad_template (gstelement_class, &srctemplate);
+
+  gst_element_class_set_static_metadata (gstelement_class, "HTTP client source",
+      "Source/Network",
+      "Receive data as a client over the network via HTTP using SOUP",
+      "Wouter Cloetens <wouter@mind.be>");
+  gstelement_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_soup_http_src_change_state);
+  gstelement_class->set_context =
+      GST_DEBUG_FUNCPTR (gst_soup_http_src_set_context);
+
+  gstbasesrc_class->start = GST_DEBUG_FUNCPTR (gst_soup_http_src_start);
+  gstbasesrc_class->stop = GST_DEBUG_FUNCPTR (gst_soup_http_src_stop);
+  gstbasesrc_class->unlock = GST_DEBUG_FUNCPTR (gst_soup_http_src_unlock);
+  gstbasesrc_class->unlock_stop =
+      GST_DEBUG_FUNCPTR (gst_soup_http_src_unlock_stop);
+  gstbasesrc_class->get_size = GST_DEBUG_FUNCPTR (gst_soup_http_src_get_size);
+  gstbasesrc_class->is_seekable =
+      GST_DEBUG_FUNCPTR (gst_soup_http_src_is_seekable);
+  gstbasesrc_class->do_seek = GST_DEBUG_FUNCPTR (gst_soup_http_src_do_seek);
+  gstbasesrc_class->query = GST_DEBUG_FUNCPTR (gst_soup_http_src_query);
+
+  gstpushsrc_class->create = GST_DEBUG_FUNCPTR (gst_soup_http_src_create);
+}
+
+static void
+gst_soup_http_src_reset (GstSoupHTTPSrc * src)
+{
+  src->retry_count = 0;
+  src->have_size = FALSE;
+  src->got_headers = FALSE;
+  src->headers_ret = GST_FLOW_OK;
+  src->seekable = FALSE;
+  src->read_position = 0;
+  src->request_position = 0;
+  src->stop_position = -1;
+  src->content_size = 0;
+  src->have_body = FALSE;
+
+  src->reduce_blocksize_count = 0;
+  src->increase_blocksize_count = 0;
+  src->last_socket_read_time = 0;
+
+  g_cancellable_reset (src->cancellable);
+
+  gst_caps_replace (&src->src_caps, NULL);
+  g_free (src->iradio_name);
+  src->iradio_name = NULL;
+  g_free (src->iradio_genre);
+  src->iradio_genre = NULL;
+  g_free (src->iradio_url);
+  src->iradio_url = NULL;
+}
+
+static void
+gst_soup_http_src_init (GstSoupHTTPSrc * src)
+{
+  const gchar *proxy;
+
+  g_mutex_init (&src->session_mutex);
+  g_cond_init (&src->session_cond);
+  src->cancellable = g_cancellable_new ();
+  src->location = NULL;
+  src->redirection_uri = NULL;
+  src->automatic_redirect = TRUE;
+  src->user_agent = g_strdup (DEFAULT_USER_AGENT);
+  src->user_id = NULL;
+  src->user_pw = NULL;
+  src->proxy_id = NULL;
+  src->proxy_pw = NULL;
+  src->cookies = NULL;
+  src->iradio_mode = DEFAULT_IRADIO_MODE;
+  src->session = NULL;
+  src->external_session = NULL;
+  src->msg = NULL;
+  src->timeout = DEFAULT_TIMEOUT;
+  src->log_level = DEFAULT_SOUP_LOG_LEVEL;
+  src->compress = DEFAULT_COMPRESS;
+  src->keep_alive = DEFAULT_KEEP_ALIVE;
+  src->ssl_strict = DEFAULT_SSL_STRICT;
+  src->ssl_use_system_ca_file = DEFAULT_SSL_USE_SYSTEM_CA_FILE;
+  src->tls_database = DEFAULT_TLS_DATABASE;
+  src->tls_interaction = DEFAULT_TLS_INTERACTION;
+  src->max_retries = DEFAULT_RETRIES;
+  src->method = DEFAULT_SOUP_METHOD;
+  src->minimum_blocksize = gst_base_src_get_blocksize (GST_BASE_SRC_CAST (src));
+  proxy = g_getenv ("http_proxy");
+  if (!gst_soup_http_src_set_proxy (src, proxy)) {
+    GST_WARNING_OBJECT (src,
+        "The proxy in the http_proxy env var (\"%s\") cannot be parsed.",
+        proxy);
+  }
+
+  gst_base_src_set_automatic_eos (GST_BASE_SRC (src), FALSE);
+
+  gst_soup_http_src_reset (src);
+}
+
+static void
+gst_soup_http_src_dispose (GObject * gobject)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (gobject);
+
+  GST_DEBUG_OBJECT (src, "dispose");
+
+  gst_soup_http_src_session_close (src);
+
+  g_clear_object (&src->external_session);
+
+  G_OBJECT_CLASS (parent_class)->dispose (gobject);
+}
+
+static void
+gst_soup_http_src_finalize (GObject * gobject)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (gobject);
+
+  GST_DEBUG_OBJECT (src, "finalize");
+
+  g_mutex_clear (&src->session_mutex);
+  g_cond_clear (&src->session_cond);
+  g_object_unref (src->cancellable);
+  g_free (src->location);
+  g_free (src->redirection_uri);
+  g_free (src->user_agent);
+  if (src->proxy != NULL) {
+    gst_soup_uri_free (src->proxy);
+  }
+  g_free (src->user_id);
+  g_free (src->user_pw);
+  g_free (src->proxy_id);
+  g_free (src->proxy_pw);
+  g_strfreev (src->cookies);
+
+  if (src->extra_headers) {
+    gst_structure_free (src->extra_headers);
+    src->extra_headers = NULL;
+  }
+
+  g_free (src->ssl_ca_file);
+
+  if (src->tls_database)
+    g_object_unref (src->tls_database);
+  g_free (src->method);
+
+  if (src->tls_interaction)
+    g_object_unref (src->tls_interaction);
+
+  G_OBJECT_CLASS (parent_class)->finalize (gobject);
+}
+
+static void
+gst_soup_http_src_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (object);
+
+  switch (prop_id) {
+    case PROP_LOCATION:
+    {
+      const gchar *location;
+
+      location = g_value_get_string (value);
+
+      if (location == NULL) {
+        GST_WARNING ("location property cannot be NULL");
+        goto done;
+      }
+      if (!gst_soup_http_src_set_location (src, location, NULL)) {
+        GST_WARNING ("badly formatted location");
+        goto done;
+      }
+      break;
+    }
+    case PROP_USER_AGENT:
+      g_free (src->user_agent);
+      src->user_agent = g_value_dup_string (value);
+      break;
+    case PROP_IRADIO_MODE:
+      src->iradio_mode = g_value_get_boolean (value);
+      break;
+    case PROP_AUTOMATIC_REDIRECT:
+      src->automatic_redirect = g_value_get_boolean (value);
+      break;
+    case PROP_PROXY:
+    {
+      const gchar *proxy;
+
+      proxy = g_value_get_string (value);
+      if (!gst_soup_http_src_set_proxy (src, proxy)) {
+        GST_WARNING ("badly formatted proxy URI");
+        goto done;
+      }
+      break;
+    }
+    case PROP_COOKIES:
+      g_strfreev (src->cookies);
+      src->cookies = g_strdupv (g_value_get_boxed (value));
+      break;
+    case PROP_IS_LIVE:
+      gst_base_src_set_live (GST_BASE_SRC (src), g_value_get_boolean (value));
+      break;
+    case PROP_USER_ID:
+      g_free (src->user_id);
+      src->user_id = g_value_dup_string (value);
+      break;
+    case PROP_USER_PW:
+      g_free (src->user_pw);
+      src->user_pw = g_value_dup_string (value);
+      break;
+    case PROP_PROXY_ID:
+      g_free (src->proxy_id);
+      src->proxy_id = g_value_dup_string (value);
+      break;
+    case PROP_PROXY_PW:
+      g_free (src->proxy_pw);
+      src->proxy_pw = g_value_dup_string (value);
+      break;
+    case PROP_TIMEOUT:
+      src->timeout = g_value_get_uint (value);
+      break;
+    case PROP_EXTRA_HEADERS:{
+      const GstStructure *s = gst_value_get_structure (value);
+
+      if (src->extra_headers)
+        gst_structure_free (src->extra_headers);
+
+      src->extra_headers = s ? gst_structure_copy (s) : NULL;
+      break;
+    }
+    case PROP_SOUP_LOG_LEVEL:
+      src->log_level = g_value_get_enum (value);
+      break;
+    case PROP_COMPRESS:
+      src->compress = g_value_get_boolean (value);
+      break;
+    case PROP_KEEP_ALIVE:
+      src->keep_alive = g_value_get_boolean (value);
+      break;
+    case PROP_SSL_STRICT:
+      src->ssl_strict = g_value_get_boolean (value);
+      break;
+    case PROP_TLS_DATABASE:
+      g_clear_object (&src->tls_database);
+      src->tls_database = g_value_dup_object (value);
+      break;
+    case PROP_TLS_INTERACTION:
+      g_clear_object (&src->tls_interaction);
+      src->tls_interaction = g_value_dup_object (value);
+      break;
+    case PROP_RETRIES:
+      src->max_retries = g_value_get_int (value);
+      break;
+    case PROP_METHOD:
+      g_free (src->method);
+      src->method = g_value_dup_string (value);
+      break;
+    case PROP_SSL_CA_FILE:
+      if (gst_soup_loader_get_api_version () == 2) {
+        g_free (src->ssl_ca_file);
+        src->ssl_ca_file = g_value_dup_string (value);
+      }
+      break;
+    case PROP_SSL_USE_SYSTEM_CA_FILE:
+      if (gst_soup_loader_get_api_version () == 2) {
+        src->ssl_use_system_ca_file = g_value_get_boolean (value);
+      }
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+done:
+  return;
+}
+
+static void
+gst_soup_http_src_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (object);
+
+  switch (prop_id) {
+    case PROP_LOCATION:
+      g_value_set_string (value, src->location);
+      break;
+    case PROP_USER_AGENT:
+      g_value_set_string (value, src->user_agent);
+      break;
+    case PROP_AUTOMATIC_REDIRECT:
+      g_value_set_boolean (value, src->automatic_redirect);
+      break;
+    case PROP_PROXY:
+      if (src->proxy == NULL)
+        g_value_set_static_string (value, "");
+      else {
+        char *proxy = gst_soup_uri_to_string (src->proxy);
+        g_value_set_string (value, proxy);
+        g_free (proxy);
+      }
+      break;
+    case PROP_COOKIES:
+      g_value_set_boxed (value, g_strdupv (src->cookies));
+      break;
+    case PROP_IS_LIVE:
+      g_value_set_boolean (value, gst_base_src_is_live (GST_BASE_SRC (src)));
+      break;
+    case PROP_IRADIO_MODE:
+      g_value_set_boolean (value, src->iradio_mode);
+      break;
+    case PROP_USER_ID:
+      g_value_set_string (value, src->user_id);
+      break;
+    case PROP_USER_PW:
+      g_value_set_string (value, src->user_pw);
+      break;
+    case PROP_PROXY_ID:
+      g_value_set_string (value, src->proxy_id);
+      break;
+    case PROP_PROXY_PW:
+      g_value_set_string (value, src->proxy_pw);
+      break;
+    case PROP_TIMEOUT:
+      g_value_set_uint (value, src->timeout);
+      break;
+    case PROP_EXTRA_HEADERS:
+      gst_value_set_structure (value, src->extra_headers);
+      break;
+    case PROP_SOUP_LOG_LEVEL:
+      g_value_set_enum (value, src->log_level);
+      break;
+    case PROP_COMPRESS:
+      g_value_set_boolean (value, src->compress);
+      break;
+    case PROP_KEEP_ALIVE:
+      g_value_set_boolean (value, src->keep_alive);
+      break;
+    case PROP_SSL_STRICT:
+      g_value_set_boolean (value, src->ssl_strict);
+      break;
+    case PROP_TLS_DATABASE:
+      g_value_set_object (value, src->tls_database);
+      break;
+    case PROP_TLS_INTERACTION:
+      g_value_set_object (value, src->tls_interaction);
+      break;
+    case PROP_RETRIES:
+      g_value_set_int (value, src->max_retries);
+      break;
+    case PROP_METHOD:
+      g_value_set_string (value, src->method);
+      break;
+    case PROP_SSL_CA_FILE:
+      if (gst_soup_loader_get_api_version () == 2)
+        g_value_set_string (value, src->ssl_ca_file);
+      break;
+    case PROP_SSL_USE_SYSTEM_CA_FILE:
+      if (gst_soup_loader_get_api_version () == 2)
+        g_value_set_boolean (value, src->ssl_use_system_ca_file);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static gchar *
+gst_soup_http_src_unicodify (const gchar * str)
+{
+  const gchar *env_vars[] = { "GST_ICY_TAG_ENCODING",
+    "GST_TAG_ENCODING", NULL
+  };
+
+  return gst_tag_freeform_string_to_utf8 (str, -1, env_vars);
+}
+
+static gboolean
+gst_soup_http_src_add_range_header (GstSoupHTTPSrc * src, guint64 offset,
+    guint64 stop_offset)
+{
+  gchar buf[64];
+  gint rc;
+  SoupMessageHeaders *request_headers =
+      _soup_message_get_request_headers (src->msg);
+
+  _soup_message_headers_remove (request_headers, "Range");
+  if (offset || stop_offset != -1) {
+    if (stop_offset != -1) {
+      g_assert (offset != stop_offset);
+
+      rc = g_snprintf (buf, sizeof (buf), "bytes=%" G_GUINT64_FORMAT "-%"
+          G_GUINT64_FORMAT, offset, (stop_offset > 0) ? stop_offset - 1 :
+          stop_offset);
+    } else {
+      rc = g_snprintf (buf, sizeof (buf), "bytes=%" G_GUINT64_FORMAT "-",
+          offset);
+    }
+    if (rc > sizeof (buf) || rc < 0)
+      return FALSE;
+    _soup_message_headers_append (request_headers, "Range", buf);
+  }
+  src->read_position = offset;
+  return TRUE;
+}
+
+static gboolean
+_append_extra_header (GQuark field_id, const GValue * value, gpointer user_data)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (user_data);
+  const gchar *field_name = g_quark_to_string (field_id);
+  gchar *field_content = NULL;
+  SoupMessageHeaders *request_headers =
+      _soup_message_get_request_headers (src->msg);
+
+  if (G_VALUE_TYPE (value) == G_TYPE_STRING) {
+    field_content = g_value_dup_string (value);
+  } else {
+    GValue dest = { 0, };
+
+    g_value_init (&dest, G_TYPE_STRING);
+    if (g_value_transform (value, &dest)) {
+      field_content = g_value_dup_string (&dest);
+    }
+  }
+
+  if (field_content == NULL) {
+    GST_ERROR_OBJECT (src, "extra-headers field '%s' contains no value "
+        "or can't be converted to a string", field_name);
+    return FALSE;
+  }
+
+  GST_DEBUG_OBJECT (src, "Appending extra header: \"%s: %s\"", field_name,
+      field_content);
+  _soup_message_headers_append (request_headers, field_name, field_content);
+
+  g_free (field_content);
+
+  return TRUE;
+}
+
+static gboolean
+_append_extra_headers (GQuark field_id, const GValue * value,
+    gpointer user_data)
+{
+  if (G_VALUE_TYPE (value) == GST_TYPE_ARRAY) {
+    guint n = gst_value_array_get_size (value);
+    guint i;
+
+    for (i = 0; i < n; i++) {
+      const GValue *v = gst_value_array_get_value (value, i);
+
+      if (!_append_extra_header (field_id, v, user_data))
+        return FALSE;
+    }
+  } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
+    guint n = gst_value_list_get_size (value);
+    guint i;
+
+    for (i = 0; i < n; i++) {
+      const GValue *v = gst_value_list_get_value (value, i);
+
+      if (!_append_extra_header (field_id, v, user_data))
+        return FALSE;
+    }
+  } else {
+    return _append_extra_header (field_id, value, user_data);
+  }
+
+  return TRUE;
+}
+
+
+static gboolean
+gst_soup_http_src_add_extra_headers (GstSoupHTTPSrc * src)
+{
+  if (!src->extra_headers)
+    return TRUE;
+
+  return gst_structure_foreach (src->extra_headers, _append_extra_headers, src);
+}
+
+static gpointer
+thread_func (gpointer user_data)
+{
+  GstSoupHTTPSrc *src = user_data;
+  GstSoupSession *session = src->session;
+  GMainContext *ctx;
+
+  GST_DEBUG_OBJECT (src, "thread start");
+
+  ctx = g_main_loop_get_context (session->loop);
+
+  g_main_context_push_thread_default (ctx);
+
+  /* We explicitly set User-Agent to NULL here and overwrite it per message
+   * to be able to have the same session with different User-Agents per
+   * source */
+  session->session =
+      _soup_session_new_with_options ("user-agent", NULL,
+      "timeout", src->timeout, "tls-interaction", src->tls_interaction,
+      /* Unset the limit the number of maximum allowed connections */
+      "max-conns", src->session_is_shared ? G_MAXINT : 10,
+      "max-conns-per-host", src->session_is_shared ? G_MAXINT : 2, NULL);
+  g_assert (session->session);
+
+  if (gst_soup_loader_get_api_version () == 3) {
+    if (src->proxy != NULL) {
+      GProxyResolver *proxy_resolver;
+      char *proxy_string = gst_soup_uri_to_string (src->proxy);
+      proxy_resolver = g_simple_proxy_resolver_new (proxy_string, NULL);
+      g_free (proxy_string);
+      g_object_set (src->session->session, "proxy-resolver", proxy_resolver,
+          NULL);
+      g_object_unref (proxy_resolver);
+    }
+#if !defined(STATIC_SOUP) || STATIC_SOUP == 2
+  } else {
+    g_object_set (session->session, "ssl-strict", src->ssl_strict, NULL);
+    if (src->proxy != NULL) {
+      /* Need #if because there's no proxy->soup_uri when STATIC_SOUP == 3 */
+      g_object_set (session->session, "proxy-uri", src->proxy->soup_uri, NULL);
+    }
+#endif
+  }
+
+  gst_soup_util_log_setup (session->session, src->log_level,
+      G_OBJECT (session));
+  if (gst_soup_loader_get_api_version () < 3) {
+    _soup_session_add_feature_by_type (session->session,
+        _soup_content_decoder_get_type ());
+  }
+  _soup_session_add_feature_by_type (session->session,
+      _soup_cookie_jar_get_type ());
+
+  /* soup2: connect the authenticate handler for the src that spawned the
+   * session (i.e. the first owner); other users of this session will connect
+   * their own after fetching the external session; the callback will handle
+   * this correctly (it checks if the message belongs to the current src
+   * and exits early if it does not)
+   */
+  if (gst_soup_loader_get_api_version () < 3) {
+    g_signal_connect (session->session, "authenticate",
+        G_CALLBACK (gst_soup_http_src_authenticate_cb_2), src);
+  }
+
+  if (!src->session_is_shared) {
+    if (src->tls_database)
+      g_object_set (src->session->session, "tls-database", src->tls_database,
+          NULL);
+    else if (gst_soup_loader_get_api_version () == 2) {
+      if (src->ssl_ca_file)
+        g_object_set (src->session->session, "ssl-ca-file", src->ssl_ca_file,
+            NULL);
+      else
+        g_object_set (src->session->session, "ssl-use-system-ca-file",
+            src->ssl_use_system_ca_file, NULL);
+    }
+  }
+
+  /* Once the main loop is running, the source element that created this
+   * session might disappear if the session is shared with other source
+   * elements.
+   */
+  src = NULL;
+
+  g_main_loop_run (session->loop);
+
+  /* Abort any pending operations on the session ... */
+  _soup_session_abort (session->session);
+  g_clear_object (&session->session);
+
+  /* ... and iterate the main context until nothing is pending anymore */
+  while (g_main_context_iteration (ctx, FALSE));
+
+  g_main_context_pop_thread_default (ctx);
+
+  GST_DEBUG_OBJECT (session, "thread stop");
+
+  return NULL;
+}
+
+static gboolean
+_session_ready_cb (gpointer user_data)
+{
+  GstSoupHTTPSrc *src = user_data;
+
+  GST_DEBUG_OBJECT (src, "thread ready");
+
+  g_mutex_lock (&src->session_mutex);
+  g_cond_signal (&src->session_cond);
+  g_mutex_unlock (&src->session_mutex);
+
+  return FALSE;
+}
+
+/* called with session_mutex taken */
+static gboolean
+gst_soup_http_src_session_open (GstSoupHTTPSrc * src)
+{
+  GstQuery *query;
+  gboolean can_share;
+
+  if (src->session) {
+    GST_DEBUG_OBJECT (src, "Session is already open");
+    return TRUE;
+  }
+
+  if (!src->location) {
+    GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ, (_("No URL set.")),
+        ("Missing location property"));
+    return FALSE;
+  }
+
+  can_share = (src->timeout == DEFAULT_TIMEOUT)
+      && (src->cookies == NULL)
+      && (src->ssl_strict == DEFAULT_SSL_STRICT)
+      && (src->tls_interaction == NULL) && (src->proxy == NULL)
+      && (src->tls_database == DEFAULT_TLS_DATABASE);
+
+  if (gst_soup_loader_get_api_version () == 2)
+    can_share = can_share && (src->ssl_ca_file == DEFAULT_SSL_CA_FILE) &&
+        (src->ssl_use_system_ca_file == DEFAULT_SSL_USE_SYSTEM_CA_FILE);
+
+  query = gst_query_new_context (GST_SOUP_SESSION_CONTEXT);
+  if (gst_pad_peer_query (GST_BASE_SRC_PAD (src), query)) {
+    GstContext *context;
+
+    gst_query_parse_context (query, &context);
+    gst_element_set_context (GST_ELEMENT_CAST (src), context);
+  } else {
+    GstMessage *message;
+
+    message =
+        gst_message_new_need_context (GST_OBJECT_CAST (src),
+        GST_SOUP_SESSION_CONTEXT);
+    gst_element_post_message (GST_ELEMENT_CAST (src), message);
+  }
+  gst_query_unref (query);
+
+  GST_OBJECT_LOCK (src);
+
+  src->session_is_shared = can_share;
+
+  if (src->external_session && can_share) {
+    GST_DEBUG_OBJECT (src, "Using external session %p", src->external_session);
+    src->session = g_object_ref (src->external_session);
+    /* for soup2, connect another authenticate handler; see thread_func */
+    if (gst_soup_loader_get_api_version () < 3) {
+      g_signal_connect (src->session->session, "authenticate",
+          G_CALLBACK (gst_soup_http_src_authenticate_cb_2), src);
+    }
+  } else {
+    GMainContext *ctx;
+    GSource *source;
+
+    GST_DEBUG_OBJECT (src, "Creating session (can share %d)", can_share);
+
+    src->session =
+        GST_SOUP_SESSION (g_object_new (GST_TYPE_SOUP_SESSION, NULL));
+
+    GST_DEBUG_OBJECT (src, "Created session %p", src->session);
+
+    ctx = g_main_context_new ();
+
+    src->session->loop = g_main_loop_new (ctx, FALSE);
+    /* now owned by the loop */
+    g_main_context_unref (ctx);
+
+    src->session->thread = g_thread_try_new ("souphttpsrc-thread",
+        thread_func, src, NULL);
+
+    if (!src->session->thread) {
+      goto err;
+    }
+
+    source = g_idle_source_new ();
+    g_source_set_callback (source, _session_ready_cb, src, NULL);
+    g_source_attach (source, ctx);
+    g_source_unref (source);
+
+    GST_DEBUG_OBJECT (src, "Waiting for thread to start...");
+    while (!g_main_loop_is_running (src->session->loop))
+      g_cond_wait (&src->session_cond, &src->session_mutex);
+    GST_DEBUG_OBJECT (src, "Soup thread started");
+  }
+
+  GST_OBJECT_UNLOCK (src);
+
+  if (src->session_is_shared) {
+    GstContext *context;
+    GstMessage *message;
+    GstStructure *s;
+
+    GST_DEBUG_OBJECT (src->session, "Sharing session %p", src->session);
+
+    context = gst_context_new (GST_SOUP_SESSION_CONTEXT, TRUE);
+    s = gst_context_writable_structure (context);
+    gst_structure_set (s, "session", GST_TYPE_SOUP_SESSION, src->session, NULL);
+
+    gst_element_set_context (GST_ELEMENT_CAST (src), context);
+    message = gst_message_new_have_context (GST_OBJECT_CAST (src), context);
+    gst_element_post_message (GST_ELEMENT_CAST (src), message);
+  }
+
+  return TRUE;
+
+err:
+  g_clear_object (&src->session);
+  GST_ELEMENT_ERROR (src, LIBRARY, INIT, (NULL), ("Failed to create session"));
+  GST_OBJECT_UNLOCK (src);
+
+  return FALSE;
+}
+
+static gboolean
+_session_close_cb (gpointer user_data)
+{
+  GstSoupHTTPSrc *src = user_data;
+
+  if (src->msg) {
+    gst_soup_session_cancel_message (src->session->session, src->msg,
+        src->cancellable);
+    g_clear_object (&src->msg);
+  }
+
+  /* there may be multiple of this callback attached to the session,
+   * each with different data pointer; disconnect the one we are closing
+   * the session for, leave the others alone
+   */
+  g_signal_handlers_disconnect_by_func (src->session->session,
+      G_CALLBACK (gst_soup_http_src_authenticate_cb_2), src);
+
+  g_mutex_lock (&src->session_mutex);
+  g_clear_object (&src->session);
+  g_cond_signal (&src->session_cond);
+  g_mutex_unlock (&src->session_mutex);
+
+  return FALSE;
+}
+
+static void
+gst_soup_http_src_session_close (GstSoupHTTPSrc * src)
+{
+  GSource *source;
+  GstSoupSession *sess;
+
+  GST_DEBUG_OBJECT (src, "Closing session");
+
+  if (!src->session) {
+    return;
+  }
+
+  /* ensure _session_close_cb does not deadlock us */
+  sess = g_object_ref (src->session);
+
+  source = g_idle_source_new ();
+
+  g_mutex_lock (&src->session_mutex);
+
+  g_source_set_callback (source, _session_close_cb, src, NULL);
+  g_source_attach (source, g_main_loop_get_context (src->session->loop));
+  g_source_unref (source);
+
+  while (src->session)
+    g_cond_wait (&src->session_cond, &src->session_mutex);
+
+  g_mutex_unlock (&src->session_mutex);
+
+  /* finally dispose of our reference from the gst thread */
+  g_object_unref (sess);
+}
+
+static void
+gst_soup_http_src_authenticate_cb_2 (SoupSession * session, SoupMessage * msg,
+    SoupAuth * auth, gboolean retrying, gpointer data)
+{
+  gst_soup_http_src_authenticate_cb (msg, auth, retrying, data);
+}
+
+static gboolean
+gst_soup_http_src_authenticate_cb (SoupMessage * msg, SoupAuth * auth,
+    gboolean retrying, gpointer data)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (data);
+  SoupStatus status_code;
+
+  /* Might be from another user of the shared session */
+  if (!GST_IS_SOUP_HTTP_SRC (src) || msg != src->msg)
+    return FALSE;
+
+  status_code = _soup_message_get_status (msg);
+
+  if (!retrying) {
+    /* First time authentication only, if we fail and are called again with
+     * retry true fall through */
+    if (status_code == SOUP_STATUS_UNAUTHORIZED) {
+      if (src->user_id && src->user_pw) {
+        _soup_auth_authenticate (auth, src->user_id, src->user_pw);
+      }
+    } else if (status_code == SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED) {
+      if (src->proxy_id && src->proxy_pw) {
+        _soup_auth_authenticate (auth, src->proxy_id, src->proxy_pw);
+      }
+    }
+  }
+
+  return FALSE;
+}
+
+static gboolean
+gst_soup_http_src_accept_certificate_cb (SoupMessage * msg,
+    GTlsCertificate * tls_certificate, GTlsCertificateFlags tls_errors,
+    gpointer user_data)
+{
+  GstSoupHTTPSrc *src = user_data;
+
+  /* Might be from another user of the shared session */
+  if (!GST_IS_SOUP_HTTP_SRC (src) || msg != src->msg)
+    return FALSE;
+
+  /* Accept invalid certificates */
+  if (!src->ssl_strict)
+    return TRUE;
+
+  return FALSE;
+}
+
+static void
+insert_http_header (const gchar * name, const gchar * value, gpointer user_data)
+{
+  GstStructure *headers = user_data;
+  const GValue *gv;
+
+  if (!g_utf8_validate (name, -1, NULL) || !g_utf8_validate (value, -1, NULL))
+    return;
+
+  gv = gst_structure_get_value (headers, name);
+  if (gv && GST_VALUE_HOLDS_ARRAY (gv)) {
+    GValue v = G_VALUE_INIT;
+
+    g_value_init (&v, G_TYPE_STRING);
+    g_value_set_string (&v, value);
+    gst_value_array_append_value ((GValue *) gv, &v);
+    g_value_unset (&v);
+  } else if (gv && G_VALUE_HOLDS_STRING (gv)) {
+    GValue arr = G_VALUE_INIT;
+    GValue v = G_VALUE_INIT;
+    const gchar *old_value = g_value_get_string (gv);
+
+    g_value_init (&arr, GST_TYPE_ARRAY);
+    g_value_init (&v, G_TYPE_STRING);
+    g_value_set_string (&v, old_value);
+    gst_value_array_append_value (&arr, &v);
+    g_value_set_string (&v, value);
+    gst_value_array_append_value (&arr, &v);
+
+    gst_structure_set_value (headers, name, &arr);
+    g_value_unset (&v);
+    g_value_unset (&arr);
+  } else {
+    gst_structure_set (headers, name, G_TYPE_STRING, value, NULL);
+  }
+}
+
+static GstFlowReturn
+gst_soup_http_src_got_headers (GstSoupHTTPSrc * src, SoupMessage * msg)
+{
+  const char *value;
+  GstTagList *tag_list;
+  GstBaseSrc *basesrc;
+  guint64 newsize;
+  GHashTable *params = NULL;
+  GstEvent *http_headers_event;
+  GstStructure *http_headers, *headers;
+  const gchar *accept_ranges;
+  SoupMessageHeaders *request_headers = _soup_message_get_request_headers (msg);
+  SoupMessageHeaders *response_headers =
+      _soup_message_get_response_headers (msg);
+  SoupStatus status_code = _soup_message_get_status (msg);
+
+  GST_INFO_OBJECT (src, "got headers");
+
+  if (status_code == SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED &&
+      src->proxy_id && src->proxy_pw) {
+    /* wait for authenticate callback */
+    return GST_FLOW_OK;
+  }
+
+  http_headers = gst_structure_new_empty ("http-headers");
+  gst_structure_set (http_headers, "uri", G_TYPE_STRING, src->location,
+      "http-status-code", G_TYPE_UINT, status_code, NULL);
+  if (src->redirection_uri)
+    gst_structure_set (http_headers, "redirection-uri", G_TYPE_STRING,
+        src->redirection_uri, NULL);
+  headers = gst_structure_new_empty ("request-headers");
+  _soup_message_headers_foreach (request_headers, insert_http_header, headers);
+  gst_structure_set (http_headers, "request-headers", GST_TYPE_STRUCTURE,
+      headers, NULL);
+  gst_structure_free (headers);
+  headers = gst_structure_new_empty ("response-headers");
+  _soup_message_headers_foreach (response_headers, insert_http_header, headers);
+  gst_structure_set (http_headers, "response-headers", GST_TYPE_STRUCTURE,
+      headers, NULL);
+  gst_structure_free (headers);
+
+  gst_element_post_message (GST_ELEMENT_CAST (src),
+      gst_message_new_element (GST_OBJECT_CAST (src),
+          gst_structure_copy (http_headers)));
+
+  if (status_code == SOUP_STATUS_UNAUTHORIZED) {
+    /* force an error */
+    gst_structure_free (http_headers);
+    return gst_soup_http_src_parse_status (msg, src);
+  }
+
+  src->got_headers = TRUE;
+
+  http_headers_event =
+      gst_event_new_custom (GST_EVENT_CUSTOM_DOWNSTREAM_STICKY, http_headers);
+  gst_event_replace (&src->http_headers_event, http_headers_event);
+  gst_event_unref (http_headers_event);
+
+  /* Parse Content-Length. */
+  if (SOUP_STATUS_IS_SUCCESSFUL (status_code) &&
+      (_soup_message_headers_get_encoding (response_headers) ==
+          SOUP_ENCODING_CONTENT_LENGTH)) {
+    newsize = src->request_position +
+        _soup_message_headers_get_content_length (response_headers);
+    if (!src->have_size || (src->content_size != newsize)) {
+      src->content_size = newsize;
+      src->have_size = TRUE;
+      src->seekable = TRUE;
+      GST_DEBUG_OBJECT (src, "size = %" G_GUINT64_FORMAT, src->content_size);
+
+      basesrc = GST_BASE_SRC_CAST (src);
+      basesrc->segment.duration = src->content_size;
+      gst_element_post_message (GST_ELEMENT (src),
+          gst_message_new_duration_changed (GST_OBJECT (src)));
+    }
+  }
+
+  /* If the server reports Accept-Ranges: none we don't have to try
+   * doing range requests at all
+   */
+  if ((accept_ranges =
+          _soup_message_headers_get_one (response_headers, "Accept-Ranges"))) {
+    if (g_ascii_strcasecmp (accept_ranges, "none") == 0)
+      src->seekable = FALSE;
+  }
+
+  /* Icecast stuff */
+  tag_list = gst_tag_list_new_empty ();
+
+  if ((value =
+          _soup_message_headers_get_one (response_headers,
+              "icy-metaint")) != NULL) {
+    gint icy_metaint;
+
+    if (g_utf8_validate (value, -1, NULL)) {
+      icy_metaint = atoi (value);
+
+      GST_DEBUG_OBJECT (src, "icy-metaint: %s (parsed: %d)", value,
+          icy_metaint);
+      if (icy_metaint > 0) {
+        if (src->src_caps)
+          gst_caps_unref (src->src_caps);
+
+        src->src_caps = gst_caps_new_simple ("application/x-icy",
+            "metadata-interval", G_TYPE_INT, icy_metaint, NULL);
+
+        gst_base_src_set_caps (GST_BASE_SRC (src), src->src_caps);
+      }
+    }
+  }
+  if ((value =
+          _soup_message_headers_get_content_type (response_headers,
+              &params)) != NULL) {
+    if (!g_utf8_validate (value, -1, NULL)) {
+      GST_WARNING_OBJECT (src, "Content-Type is invalid UTF-8");
+    } else if (g_ascii_strcasecmp (value, "audio/L16") == 0) {
+      gint channels = 2;
+      gint rate = 44100;
+      char *param;
+
+      GST_DEBUG_OBJECT (src, "Content-Type: %s", value);
+
+      if (src->src_caps) {
+        gst_caps_unref (src->src_caps);
+        src->src_caps = NULL;
+      }
+
+      param = g_hash_table_lookup (params, "channels");
+      if (param != NULL) {
+        guint64 val = g_ascii_strtoull (param, NULL, 10);
+        if (val < 64)
+          channels = val;
+        else
+          channels = 0;
+      }
+
+      param = g_hash_table_lookup (params, "rate");
+      if (param != NULL) {
+        guint64 val = g_ascii_strtoull (param, NULL, 10);
+        if (val < G_MAXINT)
+          rate = val;
+        else
+          rate = 0;
+      }
+
+      if (rate > 0 && channels > 0) {
+        src->src_caps = gst_caps_new_simple ("audio/x-unaligned-raw",
+            "format", G_TYPE_STRING, "S16BE",
+            "layout", G_TYPE_STRING, "interleaved",
+            "channels", G_TYPE_INT, channels, "rate", G_TYPE_INT, rate, NULL);
+
+        gst_base_src_set_caps (GST_BASE_SRC (src), src->src_caps);
+      }
+    } else {
+      GST_DEBUG_OBJECT (src, "Content-Type: %s", value);
+
+      /* Set the Content-Type field on the caps */
+      if (src->src_caps) {
+        src->src_caps = gst_caps_make_writable (src->src_caps);
+        gst_caps_set_simple (src->src_caps, "content-type", G_TYPE_STRING,
+            value, NULL);
+        gst_base_src_set_caps (GST_BASE_SRC (src), src->src_caps);
+      }
+    }
+  }
+
+  if (params != NULL)
+    g_hash_table_destroy (params);
+
+  if ((value =
+          _soup_message_headers_get_one (response_headers,
+              "icy-name")) != NULL) {
+    if (g_utf8_validate (value, -1, NULL)) {
+      g_free (src->iradio_name);
+      src->iradio_name = gst_soup_http_src_unicodify (value);
+      if (src->iradio_name) {
+        gst_tag_list_add (tag_list, GST_TAG_MERGE_REPLACE, GST_TAG_ORGANIZATION,
+            src->iradio_name, NULL);
+      }
+    }
+  }
+  if ((value =
+          _soup_message_headers_get_one (response_headers,
+              "icy-genre")) != NULL) {
+    if (g_utf8_validate (value, -1, NULL)) {
+      g_free (src->iradio_genre);
+      src->iradio_genre = gst_soup_http_src_unicodify (value);
+      if (src->iradio_genre) {
+        gst_tag_list_add (tag_list, GST_TAG_MERGE_REPLACE, GST_TAG_GENRE,
+            src->iradio_genre, NULL);
+      }
+    }
+  }
+  if ((value = _soup_message_headers_get_one (response_headers, "icy-url"))
+      != NULL) {
+    if (g_utf8_validate (value, -1, NULL)) {
+      g_free (src->iradio_url);
+      src->iradio_url = gst_soup_http_src_unicodify (value);
+      if (src->iradio_url) {
+        gst_tag_list_add (tag_list, GST_TAG_MERGE_REPLACE, GST_TAG_LOCATION,
+            src->iradio_url, NULL);
+      }
+    }
+  }
+  if (!gst_tag_list_is_empty (tag_list)) {
+    GST_DEBUG_OBJECT (src,
+        "calling gst_element_found_tags with %" GST_PTR_FORMAT, tag_list);
+    gst_pad_push_event (GST_BASE_SRC_PAD (src), gst_event_new_tag (tag_list));
+  } else {
+    gst_tag_list_unref (tag_list);
+  }
+
+  /* Handle HTTP errors. */
+  return gst_soup_http_src_parse_status (msg, src);
+}
+
+static GstBuffer *
+gst_soup_http_src_alloc_buffer (GstSoupHTTPSrc * src)
+{
+  GstBaseSrc *basesrc = GST_BASE_SRC_CAST (src);
+  GstFlowReturn rc;
+  GstBuffer *gstbuf;
+
+  rc = GST_BASE_SRC_CLASS (parent_class)->alloc (basesrc, -1,
+      basesrc->blocksize, &gstbuf);
+  if (G_UNLIKELY (rc != GST_FLOW_OK)) {
+    return NULL;
+  }
+
+  return gstbuf;
+}
+
+#define SOUP_HTTP_SRC_ERROR(src,soup_msg,cat,code,error_message)     \
+  do { \
+    GST_ELEMENT_ERROR_WITH_DETAILS ((src), cat, code, ("%s", error_message), \
+        ("%s (%d), URL: %s, Redirect to: %s", _soup_message_get_reason_phrase (soup_msg), \
+            _soup_message_get_status (soup_msg), (src)->location, GST_STR_NULL ((src)->redirection_uri)), \
+            ("http-status-code", G_TYPE_UINT, _soup_message_get_status (soup_msg), \
+             "http-redirect-uri", G_TYPE_STRING, GST_STR_NULL ((src)->redirection_uri), NULL)); \
+  } while(0)
+
+static GstFlowReturn
+gst_soup_http_src_parse_status (SoupMessage * msg, GstSoupHTTPSrc * src)
+{
+  SoupStatus status_code = _soup_message_get_status (msg);
+  if (_soup_message_get_method (msg) == SOUP_METHOD_HEAD) {
+    if (!SOUP_STATUS_IS_SUCCESSFUL (status_code))
+      GST_DEBUG_OBJECT (src, "Ignoring error %d during HEAD request",
+          status_code);
+    return GST_FLOW_OK;
+  }
+
+  /* SOUP_STATUS_IS_TRANSPORT_ERROR was replaced with GError in libsoup-3.0 */
+#if !defined(STATIC_SOUP) || STATIC_SOUP == 2
+  if (SOUP_STATUS_IS_TRANSPORT_ERROR (status_code)) {
+    switch (status_code) {
+      case SOUP_STATUS_CANT_RESOLVE:
+      case SOUP_STATUS_CANT_RESOLVE_PROXY:
+        SOUP_HTTP_SRC_ERROR (src, msg, RESOURCE, NOT_FOUND,
+            _("Could not resolve server name."));
+        return GST_FLOW_ERROR;
+      case SOUP_STATUS_CANT_CONNECT:
+      case SOUP_STATUS_CANT_CONNECT_PROXY:
+        SOUP_HTTP_SRC_ERROR (src, msg, RESOURCE, OPEN_READ,
+            _("Could not establish connection to server."));
+        return GST_FLOW_ERROR;
+      case SOUP_STATUS_SSL_FAILED:
+        SOUP_HTTP_SRC_ERROR (src, msg, RESOURCE, OPEN_READ,
+            _("Secure connection setup failed."));
+        return GST_FLOW_ERROR;
+      case SOUP_STATUS_IO_ERROR:
+        if (src->max_retries == -1 || src->retry_count < src->max_retries)
+          return GST_FLOW_CUSTOM_ERROR;
+        SOUP_HTTP_SRC_ERROR (src, msg, RESOURCE, READ,
+            _("A network error occurred, or the server closed the connection "
+                "unexpectedly."));
+        return GST_FLOW_ERROR;
+      case SOUP_STATUS_MALFORMED:
+        SOUP_HTTP_SRC_ERROR (src, msg, RESOURCE, READ,
+            _("Server sent bad data."));
+        return GST_FLOW_ERROR;
+      case SOUP_STATUS_CANCELLED:
+        /* No error message when interrupted by program. */
+        break;
+      default:
+        break;
+    }
+    return GST_FLOW_OK;
+  }
+#endif
+
+  if (SOUP_STATUS_IS_CLIENT_ERROR (status_code) ||
+      SOUP_STATUS_IS_REDIRECTION (status_code) ||
+      SOUP_STATUS_IS_SERVER_ERROR (status_code)) {
+    const gchar *reason_phrase;
+
+    reason_phrase = _soup_message_get_reason_phrase (msg);
+    if (reason_phrase && !g_utf8_validate (reason_phrase, -1, NULL)) {
+      GST_ERROR_OBJECT (src, "Invalid UTF-8 in reason");
+      reason_phrase = "(invalid)";
+    }
+
+    /* Report HTTP error. */
+
+    /* when content_size is unknown and we have just finished receiving
+     * a body message, requests that go beyond the content limits will result
+     * in an error. Here we convert those to EOS */
+    if (status_code == SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE &&
+        src->have_body && (!src->have_size ||
+            (src->request_position >= src->content_size))) {
+      GST_DEBUG_OBJECT (src, "Requested range out of limits and received full "
+          "body, returning EOS");
+      return GST_FLOW_EOS;
+    }
+
+    /* FIXME: reason_phrase is not translated and not suitable for user
+     * error dialog according to libsoup documentation.
+     */
+    if (status_code == SOUP_STATUS_NOT_FOUND) {
+      SOUP_HTTP_SRC_ERROR (src, msg, RESOURCE, NOT_FOUND, (reason_phrase));
+    } else if (status_code == SOUP_STATUS_UNAUTHORIZED
+        || status_code == SOUP_STATUS_PAYMENT_REQUIRED
+        || status_code == SOUP_STATUS_FORBIDDEN
+        || status_code == SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED) {
+      SOUP_HTTP_SRC_ERROR (src, msg, RESOURCE, NOT_AUTHORIZED, (reason_phrase));
+    } else {
+      SOUP_HTTP_SRC_ERROR (src, msg, RESOURCE, OPEN_READ, (reason_phrase));
+    }
+    return GST_FLOW_ERROR;
+  }
+
+  return GST_FLOW_OK;
+}
+
+static void
+gst_soup_http_src_restarted_cb (SoupMessage * msg, GstSoupHTTPSrc * src)
+{
+  SoupStatus status = _soup_message_get_status (msg);
+
+  if (!SOUP_STATUS_IS_REDIRECTION (status))
+    return;
+
+  src->redirection_uri = gst_soup_message_uri_to_string (msg);
+  src->redirection_permanent = (status == SOUP_STATUS_MOVED_PERMANENTLY);
+
+  GST_DEBUG_OBJECT (src, "%u redirect to \"%s\" (permanent %d)",
+      status, src->redirection_uri, src->redirection_permanent);
+}
+
+static gboolean
+gst_soup_http_src_build_message (GstSoupHTTPSrc * src, const gchar * method)
+{
+  SoupMessageHeaders *request_headers;
+
+  g_return_val_if_fail (src->msg == NULL, FALSE);
+
+  src->msg = _soup_message_new (method, src->location);
+  if (!src->msg) {
+    GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ,
+        ("Error parsing URL."), ("URL: %s", src->location));
+    return FALSE;
+  }
+
+  request_headers = _soup_message_get_request_headers (src->msg);
+
+  /* Duplicating the defaults of libsoup here. We don't want to set a
+   * User-Agent in the session as each source might have its own User-Agent
+   * set */
+  if (!src->user_agent || !*src->user_agent) {
+    gchar *user_agent =
+        g_strdup_printf ("libsoup/%u.%u.%u", _soup_get_major_version (),
+        _soup_get_minor_version (), _soup_get_micro_version ());
+    _soup_message_headers_append (request_headers, "User-Agent", user_agent);
+    g_free (user_agent);
+  } else if (g_str_has_suffix (src->user_agent, " ")) {
+    gchar *user_agent = g_strdup_printf ("%slibsoup/%u.%u.%u", src->user_agent,
+        _soup_get_major_version (),
+        _soup_get_minor_version (), _soup_get_micro_version ());
+    _soup_message_headers_append (request_headers, "User-Agent", user_agent);
+    g_free (user_agent);
+  } else {
+    _soup_message_headers_append (request_headers, "User-Agent",
+        src->user_agent);
+  }
+
+  if (!src->keep_alive) {
+    _soup_message_headers_append (request_headers, "Connection", "close");
+  }
+  if (src->iradio_mode) {
+    _soup_message_headers_append (request_headers, "icy-metadata", "1");
+  }
+  if (src->cookies) {
+    gchar **cookie;
+
+    for (cookie = src->cookies; *cookie != NULL; cookie++) {
+      _soup_message_headers_append (request_headers, "Cookie", *cookie);
+    }
+
+    _soup_message_disable_feature (src->msg, _soup_cookie_jar_get_type ());
+  }
+
+  if (!src->compress) {
+    _soup_message_headers_append (_soup_message_get_request_headers (src->msg),
+        "Accept-Encoding", "identity");
+  }
+
+  if (gst_soup_loader_get_api_version () == 3) {
+    g_signal_connect (src->msg, "accept-certificate",
+        G_CALLBACK (gst_soup_http_src_accept_certificate_cb), src);
+    g_signal_connect (src->msg, "authenticate",
+        G_CALLBACK (gst_soup_http_src_authenticate_cb), src);
+  }
+
+  {
+    SoupMessageFlags flags =
+        src->automatic_redirect ? 0 : SOUP_MESSAGE_NO_REDIRECT;
+
+    /* SOUP_MESSAGE_OVERWRITE_CHUNKS is gone in libsoup-3.0, and
+     * soup_message_body_set_accumulate() requires SoupMessageBody, which
+     * can only be fetched from SoupServerMessage, not SoupMessage */
+#if !defined(STATIC_SOUP) || STATIC_SOUP == 2
+    if (gst_soup_loader_get_api_version () == 2)
+      flags |= SOUP_MESSAGE_OVERWRITE_CHUNKS;
+#endif
+
+    _soup_message_set_flags (src->msg, flags);
+  }
+
+  if (src->automatic_redirect) {
+    g_signal_connect (src->msg, "restarted",
+        G_CALLBACK (gst_soup_http_src_restarted_cb), src);
+  }
+
+  gst_soup_http_src_add_range_header (src, src->request_position,
+      src->stop_position);
+
+  gst_soup_http_src_add_extra_headers (src);
+
+  return TRUE;
+}
+
+struct GstSoupSendSrc
+{
+  GstSoupHTTPSrc *src;
+  GError *error;
+};
+
+static void
+_session_send_cb (GObject * source, GAsyncResult * res, gpointer user_data)
+{
+  struct GstSoupSendSrc *msrc = user_data;
+  GstSoupHTTPSrc *src = msrc->src;
+  GError *error = NULL;
+
+  g_mutex_lock (&src->session_mutex);
+
+  src->input_stream = _soup_session_send_finish (src->session->session,
+      res, &error);
+
+  if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+    src->headers_ret = GST_FLOW_FLUSHING;
+  } else {
+    src->headers_ret = gst_soup_http_src_got_headers (src, src->msg);
+  }
+
+  if (!src->input_stream) {
+    GST_DEBUG_OBJECT (src, "Sending message failed: %s", error->message);
+    msrc->error = error;
+  }
+
+  g_cond_broadcast (&src->session_cond);
+  g_mutex_unlock (&src->session_mutex);
+}
+
+static gboolean
+_session_send_idle_cb (gpointer user_data)
+{
+  struct GstSoupSendSrc *msrc = user_data;
+  GstSoupHTTPSrc *src = msrc->src;
+
+  _soup_session_send_async (src->session->session, src->msg, src->cancellable,
+      _session_send_cb, msrc);
+
+  return FALSE;
+}
+
+/* called with session lock taken */
+static GstFlowReturn
+gst_soup_http_src_send_message (GstSoupHTTPSrc * src)
+{
+  GstFlowReturn ret;
+  GSource *source;
+  struct GstSoupSendSrc msrc;
+
+  g_return_val_if_fail (src->msg != NULL, GST_FLOW_ERROR);
+  g_assert (src->input_stream == NULL);
+
+  msrc.src = src;
+  msrc.error = NULL;
+
+  source = g_idle_source_new ();
+
+  src->headers_ret = GST_FLOW_OK;
+
+  g_source_set_callback (source, _session_send_idle_cb, &msrc, NULL);
+  g_source_attach (source, g_main_loop_get_context (src->session->loop));
+  g_source_unref (source);
+
+  while (!src->input_stream && !msrc.error)
+    g_cond_wait (&src->session_cond, &src->session_mutex);
+
+  ret = src->headers_ret;
+
+  if (ret != GST_FLOW_OK) {
+    goto done;
+  }
+
+  if (!src->input_stream) {
+    GST_DEBUG_OBJECT (src, "Didn't get an input stream: %s",
+        msrc.error->message);
+    ret = GST_FLOW_ERROR;
+    goto done;
+  }
+
+  /* if an input stream exists, it was always successful */
+  GST_DEBUG_OBJECT (src, "Successfully got a reply");
+
+done:
+  g_clear_error (&msrc.error);
+  return ret;
+}
+
+/* called with session lock taken */
+static GstFlowReturn
+gst_soup_http_src_do_request (GstSoupHTTPSrc * src, const gchar * method)
+{
+  GstFlowReturn ret;
+  SoupMessageHeaders *request_headers;
+
+  if (src->max_retries != -1 && src->retry_count > src->max_retries) {
+    GST_DEBUG_OBJECT (src, "Max retries reached");
+    return GST_FLOW_ERROR;
+  }
+
+  src->retry_count++;
+  /* EOS immediately if we have an empty segment */
+  if (src->request_position == src->stop_position)
+    return GST_FLOW_EOS;
+
+  GST_LOG_OBJECT (src, "Running request for method: %s", method);
+
+  if (src->msg)
+    request_headers = _soup_message_get_request_headers (src->msg);
+
+  /* Update the position if we are retrying */
+  if (src->msg && src->request_position > 0) {
+    gst_soup_http_src_add_range_header (src, src->request_position,
+        src->stop_position);
+  } else if (src->msg && src->request_position == 0)
+    _soup_message_headers_remove (request_headers, "Range");
+
+  /* add_range_header() has the side effect of setting read_position to
+   * the requested position. This *needs* to be set regardless of having
+   * a message or not. Failure to do so would result in calculation being
+   * done with stale/wrong read position */
+  src->read_position = src->request_position;
+
+  if (!src->msg) {
+    if (!gst_soup_http_src_build_message (src, method)) {
+      return GST_FLOW_ERROR;
+    }
+  }
+
+  if (g_cancellable_is_cancelled (src->cancellable)) {
+    GST_INFO_OBJECT (src, "interrupted");
+    return GST_FLOW_FLUSHING;
+  }
+
+  ret = gst_soup_http_src_send_message (src);
+
+  /* Check if Range header was respected. */
+  if (ret == GST_FLOW_OK && src->request_position > 0 &&
+      _soup_message_get_status (src->msg) != SOUP_STATUS_PARTIAL_CONTENT) {
+    src->seekable = FALSE;
+    GST_ELEMENT_ERROR_WITH_DETAILS (src, RESOURCE, SEEK,
+        (_("Server does not support seeking.")),
+        ("Server does not accept Range HTTP header, URL: %s, Redirect to: %s",
+            src->location, GST_STR_NULL (src->redirection_uri)),
+        ("http-status-code", G_TYPE_UINT, _soup_message_get_status (src->msg),
+            "http-redirection-uri", G_TYPE_STRING,
+            GST_STR_NULL (src->redirection_uri), NULL));
+    ret = GST_FLOW_ERROR;
+  }
+
+  return ret;
+}
+
+/*
+ * Check if the bytes_read is above a certain threshold of the blocksize, if
+ * that happens a few times in a row, increase the blocksize; Do the same in
+ * the opposite direction to reduce the blocksize.
+ */
+static void
+gst_soup_http_src_check_update_blocksize (GstSoupHTTPSrc * src,
+    gint64 bytes_read)
+{
+  guint blocksize = gst_base_src_get_blocksize (GST_BASE_SRC_CAST (src));
+
+  gint64 time_since_last_read =
+      g_get_monotonic_time () * GST_USECOND - src->last_socket_read_time;
+
+  GST_LOG_OBJECT (src, "Checking to update blocksize. Read: %" G_GINT64_FORMAT
+      " bytes, blocksize: %u bytes, time since last read: %" GST_TIME_FORMAT,
+      bytes_read, blocksize, GST_TIME_ARGS (time_since_last_read));
+
+  if (bytes_read >= blocksize * GROW_BLOCKSIZE_LIMIT
+      && time_since_last_read <= GROW_TIME_LIMIT) {
+    src->reduce_blocksize_count = 0;
+    src->increase_blocksize_count++;
+
+    if (src->increase_blocksize_count >= GROW_BLOCKSIZE_COUNT) {
+      blocksize *= GROW_BLOCKSIZE_FACTOR;
+      GST_DEBUG_OBJECT (src, "Increased blocksize to %u", blocksize);
+      gst_base_src_set_blocksize (GST_BASE_SRC_CAST (src), blocksize);
+      src->increase_blocksize_count = 0;
+    }
+  } else if (bytes_read < blocksize * REDUCE_BLOCKSIZE_LIMIT
+      || time_since_last_read > GROW_TIME_LIMIT) {
+    src->reduce_blocksize_count++;
+    src->increase_blocksize_count = 0;
+
+    if (src->reduce_blocksize_count >= REDUCE_BLOCKSIZE_COUNT) {
+      blocksize *= REDUCE_BLOCKSIZE_FACTOR;
+      blocksize = MAX (blocksize, src->minimum_blocksize);
+      GST_DEBUG_OBJECT (src, "Decreased blocksize to %u", blocksize);
+      gst_base_src_set_blocksize (GST_BASE_SRC_CAST (src), blocksize);
+      src->reduce_blocksize_count = 0;
+    }
+  } else {
+    src->reduce_blocksize_count = src->increase_blocksize_count = 0;
+  }
+}
+
+static void
+gst_soup_http_src_update_position (GstSoupHTTPSrc * src, gint64 bytes_read)
+{
+  GstBaseSrc *basesrc = GST_BASE_SRC_CAST (src);
+  guint64 new_position;
+
+  new_position = src->read_position + bytes_read;
+  if (G_LIKELY (src->request_position == src->read_position))
+    src->request_position = new_position;
+  src->read_position = new_position;
+
+  if (src->have_size) {
+    if (new_position > src->content_size) {
+      GST_DEBUG_OBJECT (src, "Got position previous estimated content size "
+          "(%" G_GINT64_FORMAT " > %" G_GINT64_FORMAT ")", new_position,
+          src->content_size);
+      src->content_size = new_position;
+      basesrc->segment.duration = src->content_size;
+      gst_element_post_message (GST_ELEMENT (src),
+          gst_message_new_duration_changed (GST_OBJECT (src)));
+    } else if (new_position == src->content_size) {
+      GST_DEBUG_OBJECT (src, "We're EOS now");
+    }
+  }
+}
+
+struct GstSoupReadResult
+{
+  GstSoupHTTPSrc *src;
+  GError *error;
+  void *buffer;
+  gsize bufsize;
+  gssize nbytes;
+};
+
+static void
+_session_read_cb (GObject * source, GAsyncResult * ret, gpointer user_data)
+{
+  struct GstSoupReadResult *res = user_data;
+
+  g_mutex_lock (&res->src->session_mutex);
+
+  res->nbytes = g_input_stream_read_finish (G_INPUT_STREAM (source),
+      ret, &res->error);
+
+  g_cond_signal (&res->src->session_cond);
+  g_mutex_unlock (&res->src->session_mutex);
+}
+
+static gboolean
+_session_read_idle_cb (gpointer user_data)
+{
+  struct GstSoupReadResult *res = user_data;
+
+  g_input_stream_read_async (res->src->input_stream, res->buffer,
+      res->bufsize, G_PRIORITY_DEFAULT, res->src->cancellable,
+      _session_read_cb, res);
+
+  return FALSE;
+}
+
+static GstFlowReturn
+gst_soup_http_src_read_buffer (GstSoupHTTPSrc * src, GstBuffer ** outbuf)
+{
+  struct GstSoupReadResult res;
+  GstMapInfo mapinfo;
+  GstBaseSrc *bsrc;
+  GstFlowReturn ret;
+  GSource *source;
+
+  bsrc = GST_BASE_SRC_CAST (src);
+
+  *outbuf = gst_soup_http_src_alloc_buffer (src);
+  if (!*outbuf) {
+    GST_WARNING_OBJECT (src, "Failed to allocate buffer");
+    return GST_FLOW_ERROR;
+  }
+
+  if (!gst_buffer_map (*outbuf, &mapinfo, GST_MAP_WRITE)) {
+    GST_WARNING_OBJECT (src, "Failed to map buffer");
+    return GST_FLOW_ERROR;
+  }
+
+  res.src = src;
+  res.buffer = mapinfo.data;
+  res.bufsize = mapinfo.size;
+  res.error = NULL;
+  res.nbytes = -1;
+
+  source = g_idle_source_new ();
+
+  g_mutex_lock (&src->session_mutex);
+
+  g_source_set_callback (source, _session_read_idle_cb, &res, NULL);
+  /* invoke on libsoup thread */
+  g_source_attach (source, g_main_loop_get_context (src->session->loop));
+  g_source_unref (source);
+
+  /* wait for it */
+  while (!res.error && res.nbytes < 0)
+    g_cond_wait (&src->session_cond, &src->session_mutex);
+  g_mutex_unlock (&src->session_mutex);
+
+  GST_DEBUG_OBJECT (src, "Read %" G_GSSIZE_FORMAT " bytes from http input",
+      res.nbytes);
+
+  if (res.error) {
+    /* retry by default */
+    GstFlowReturn ret = GST_FLOW_CUSTOM_ERROR;
+    if (g_error_matches (res.error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+      ret = GST_FLOW_FLUSHING;
+    } else {
+      GST_ERROR_OBJECT (src, "Got error from libsoup: %s", res.error->message);
+    }
+    g_error_free (res.error);
+    gst_buffer_unmap (*outbuf, &mapinfo);
+    gst_buffer_unref (*outbuf);
+    return ret;
+  }
+
+  gst_buffer_unmap (*outbuf, &mapinfo);
+  if (res.nbytes > 0) {
+    gst_buffer_set_size (*outbuf, res.nbytes);
+    GST_BUFFER_OFFSET (*outbuf) = bsrc->segment.position;
+    ret = GST_FLOW_OK;
+    gst_soup_http_src_update_position (src, res.nbytes);
+
+    /* Got some data, reset retry counter */
+    src->retry_count = 0;
+
+    gst_soup_http_src_check_update_blocksize (src, res.nbytes);
+
+    src->last_socket_read_time = g_get_monotonic_time () * GST_USECOND;
+
+    /* If we're at the end of a range request, read again to let libsoup
+     * finalize the request. This allows to reuse the connection again later,
+     * otherwise we would have to cancel the message and close the connection
+     */
+    if (bsrc->segment.stop != -1
+        && bsrc->segment.position + res.nbytes >= bsrc->segment.stop) {
+      SoupMessage *msg = src->msg;
+      guint8 tmp[128];
+
+      res.buffer = tmp;
+      res.bufsize = sizeof (tmp);
+      res.nbytes = -1;
+
+      src->msg = NULL;
+      src->have_body = TRUE;
+
+      g_mutex_lock (&src->session_mutex);
+
+      source = g_idle_source_new ();
+
+      g_source_set_callback (source, _session_read_idle_cb, &res, NULL);
+      /* This should return immediately as we're at the end of the range */
+      g_source_attach (source, g_main_loop_get_context (src->session->loop));
+      g_source_unref (source);
+
+      while (!res.error && res.nbytes < 0)
+        g_cond_wait (&src->session_cond, &src->session_mutex);
+      g_mutex_unlock (&src->session_mutex);
+
+      g_clear_error (&res.error);
+      g_object_unref (msg);
+
+      if (res.nbytes > 0)
+        GST_ERROR_OBJECT (src,
+            "Read %" G_GSIZE_FORMAT " bytes after end of range", res.nbytes);
+    }
+  } else {
+    gst_buffer_unref (*outbuf);
+    if (src->have_size && src->read_position < src->content_size) {
+      /* Maybe the server disconnected, retry */
+      ret = GST_FLOW_CUSTOM_ERROR;
+    } else {
+      g_clear_object (&src->msg);
+      src->msg = NULL;
+      ret = GST_FLOW_EOS;
+      src->have_body = TRUE;
+    }
+  }
+
+  g_clear_error (&res.error);
+
+  return ret;
+}
+
+static gboolean
+_session_stream_clear_cb (gpointer user_data)
+{
+  GstSoupHTTPSrc *src = user_data;
+
+  g_mutex_lock (&src->session_mutex);
+
+  g_clear_object (&src->input_stream);
+
+  g_cond_signal (&src->session_cond);
+  g_mutex_unlock (&src->session_mutex);
+
+  return FALSE;
+}
+
+static void
+gst_soup_http_src_stream_clear (GstSoupHTTPSrc * src)
+{
+  GSource *source;
+
+  if (!src->input_stream)
+    return;
+
+  g_mutex_lock (&src->session_mutex);
+
+  source = g_idle_source_new ();
+
+  g_source_set_callback (source, _session_stream_clear_cb, src, NULL);
+  g_source_attach (source, g_main_loop_get_context (src->session->loop));
+  g_source_unref (source);
+
+  while (src->input_stream)
+    g_cond_wait (&src->session_cond, &src->session_mutex);
+
+  g_mutex_unlock (&src->session_mutex);
+}
+
+static GstFlowReturn
+gst_soup_http_src_create (GstPushSrc * psrc, GstBuffer ** outbuf)
+{
+  GstSoupHTTPSrc *src;
+  GstFlowReturn ret = GST_FLOW_OK;
+  GstEvent *http_headers_event = NULL;
+
+  src = GST_SOUP_HTTP_SRC (psrc);
+
+retry:
+
+  /* Check for pending position change */
+  if (src->request_position != src->read_position && src->input_stream) {
+    gst_soup_http_src_stream_clear (src);
+  }
+
+  if (g_cancellable_is_cancelled (src->cancellable)) {
+    ret = GST_FLOW_FLUSHING;
+    goto done;
+  }
+
+  /* If we have no open connection to the server, start one */
+  if (!src->input_stream) {
+    *outbuf = NULL;
+    g_mutex_lock (&src->session_mutex);
+    ret =
+        gst_soup_http_src_do_request (src,
+        src->method ? src->method : SOUP_METHOD_GET);
+    http_headers_event = src->http_headers_event;
+    src->http_headers_event = NULL;
+    g_mutex_unlock (&src->session_mutex);
+  }
+
+  if (ret == GST_FLOW_OK || ret == GST_FLOW_CUSTOM_ERROR) {
+    if (http_headers_event) {
+      gst_pad_push_event (GST_BASE_SRC_PAD (src), http_headers_event);
+      http_headers_event = NULL;
+    }
+  }
+
+  if (ret == GST_FLOW_OK)
+    ret = gst_soup_http_src_read_buffer (src, outbuf);
+
+done:
+  GST_DEBUG_OBJECT (src, "Returning %d %s", ret, gst_flow_get_name (ret));
+  if (ret != GST_FLOW_OK) {
+    if (http_headers_event)
+      gst_event_unref (http_headers_event);
+
+    if (src->input_stream) {
+      gst_soup_http_src_stream_clear (src);
+    }
+    if (ret == GST_FLOW_CUSTOM_ERROR) {
+      ret = GST_FLOW_OK;
+      goto retry;
+    }
+  }
+
+  if (ret == GST_FLOW_FLUSHING) {
+    src->retry_count = 0;
+  }
+
+  return ret;
+}
+
+static gboolean
+gst_soup_http_src_start (GstBaseSrc * bsrc)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (bsrc);
+  gboolean ret;
+
+  GST_DEBUG_OBJECT (src, "start(\"%s\")", src->location);
+
+  g_mutex_lock (&src->session_mutex);
+  ret = gst_soup_http_src_session_open (src);
+  g_mutex_unlock (&src->session_mutex);
+  return ret;
+}
+
+static gboolean
+gst_soup_http_src_stop (GstBaseSrc * bsrc)
+{
+  GstSoupHTTPSrc *src;
+
+  src = GST_SOUP_HTTP_SRC (bsrc);
+  GST_DEBUG_OBJECT (src, "stop()");
+
+  gst_soup_http_src_stream_clear (src);
+
+  if (src->keep_alive && !src->msg && !src->session_is_shared)
+    g_cancellable_cancel (src->cancellable);
+  else
+    gst_soup_http_src_session_close (src);
+
+  gst_soup_http_src_reset (src);
+  return TRUE;
+}
+
+static GstStateChangeReturn
+gst_soup_http_src_change_state (GstElement * element, GstStateChange transition)
+{
+  GstStateChangeReturn ret;
+  GstSoupHTTPSrc *src;
+
+  src = GST_SOUP_HTTP_SRC (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      gst_soup_http_src_session_close (src);
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  return ret;
+}
+
+static void
+gst_soup_http_src_set_context (GstElement * element, GstContext * context)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (element);
+
+  if (g_strcmp0 (gst_context_get_context_type (context),
+          GST_SOUP_SESSION_CONTEXT) == 0) {
+    const GstStructure *s = gst_context_get_structure (context);
+
+    GST_OBJECT_LOCK (src);
+
+    g_clear_object (&src->external_session);
+    gst_structure_get (s, "session", GST_TYPE_SOUP_SESSION,
+        &src->external_session, NULL);
+
+    GST_DEBUG_OBJECT (src, "Setting external session %p",
+        src->external_session);
+    GST_OBJECT_UNLOCK (src);
+  }
+
+  GST_ELEMENT_CLASS (parent_class)->set_context (element, context);
+}
+
+/* Interrupt a blocking request. */
+static gboolean
+gst_soup_http_src_unlock (GstBaseSrc * bsrc)
+{
+  GstSoupHTTPSrc *src;
+
+  src = GST_SOUP_HTTP_SRC (bsrc);
+  GST_DEBUG_OBJECT (src, "unlock()");
+
+  g_cancellable_cancel (src->cancellable);
+  return TRUE;
+}
+
+/* Interrupt interrupt. */
+static gboolean
+gst_soup_http_src_unlock_stop (GstBaseSrc * bsrc)
+{
+  GstSoupHTTPSrc *src;
+
+  src = GST_SOUP_HTTP_SRC (bsrc);
+  GST_DEBUG_OBJECT (src, "unlock_stop()");
+
+  g_cancellable_reset (src->cancellable);
+  return TRUE;
+}
+
+static gboolean
+gst_soup_http_src_get_size (GstBaseSrc * bsrc, guint64 * size)
+{
+  GstSoupHTTPSrc *src;
+
+  src = GST_SOUP_HTTP_SRC (bsrc);
+
+  if (src->have_size) {
+    GST_DEBUG_OBJECT (src, "get_size() = %" G_GUINT64_FORMAT,
+        src->content_size);
+    *size = src->content_size;
+    return TRUE;
+  }
+  GST_DEBUG_OBJECT (src, "get_size() = FALSE");
+  return FALSE;
+}
+
+static void
+gst_soup_http_src_check_seekable (GstSoupHTTPSrc * src)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  /* Special case to check if the server allows range requests
+   * before really starting to get data in the buffer creation
+   * loops.
+   */
+  if (!src->got_headers && GST_STATE (src) >= GST_STATE_PAUSED) {
+    g_mutex_lock (&src->session_mutex);
+    while (!src->got_headers && !g_cancellable_is_cancelled (src->cancellable)
+        && ret == GST_FLOW_OK) {
+      if ((src->msg && _soup_message_get_method (src->msg) != SOUP_METHOD_HEAD)) {
+        /* wait for the current request to finish */
+        g_cond_wait (&src->session_cond, &src->session_mutex);
+        ret = src->headers_ret;
+      } else {
+        if (gst_soup_http_src_session_open (src)) {
+          ret = gst_soup_http_src_do_request (src, SOUP_METHOD_HEAD);
+        }
+      }
+    }
+    g_mutex_unlock (&src->session_mutex);
+  }
+}
+
+static gboolean
+gst_soup_http_src_is_seekable (GstBaseSrc * bsrc)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (bsrc);
+
+  gst_soup_http_src_check_seekable (src);
+
+  return src->seekable;
+}
+
+static gboolean
+gst_soup_http_src_do_seek (GstBaseSrc * bsrc, GstSegment * segment)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (bsrc);
+
+  GST_DEBUG_OBJECT (src, "do_seek(%" G_GUINT64_FORMAT "-%" G_GUINT64_FORMAT
+      ")", segment->start, segment->stop);
+  if (src->read_position == segment->start &&
+      src->request_position == src->read_position &&
+      src->stop_position == segment->stop) {
+    GST_DEBUG_OBJECT (src,
+        "Seek to current read/end position and no seek pending");
+    return TRUE;
+  }
+
+  gst_soup_http_src_check_seekable (src);
+
+  /* If we have no headers we don't know yet if it is seekable or not.
+   * Store the start position and error out later if it isn't */
+  if (src->got_headers && !src->seekable) {
+    GST_WARNING_OBJECT (src, "Not seekable");
+    return FALSE;
+  }
+
+  if (segment->rate < 0.0 || segment->format != GST_FORMAT_BYTES) {
+    GST_WARNING_OBJECT (src, "Invalid seek segment");
+    return FALSE;
+  }
+
+  if (src->have_size && segment->start >= src->content_size) {
+    GST_WARNING_OBJECT (src,
+        "Potentially seeking behind end of file, might EOS immediately");
+  }
+
+  /* Wait for create() to handle the jump in offset. */
+  src->request_position = segment->start;
+  src->stop_position = segment->stop;
+
+  return TRUE;
+}
+
+static gboolean
+gst_soup_http_src_query (GstBaseSrc * bsrc, GstQuery * query)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (bsrc);
+  gboolean ret;
+  GstSchedulingFlags flags;
+  gint minsize, maxsize, align;
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_URI:
+      gst_query_set_uri (query, src->location);
+      if (src->redirection_uri != NULL) {
+        gst_query_set_uri_redirection (query, src->redirection_uri);
+        gst_query_set_uri_redirection_permanent (query,
+            src->redirection_permanent);
+      }
+      ret = TRUE;
+      break;
+    default:
+      ret = FALSE;
+      break;
+  }
+
+  if (!ret)
+    ret = GST_BASE_SRC_CLASS (parent_class)->query (bsrc, query);
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_SCHEDULING:
+      gst_query_parse_scheduling (query, &flags, &minsize, &maxsize, &align);
+      flags |= GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED;
+      gst_query_set_scheduling (query, flags, minsize, maxsize, align);
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static gboolean
+gst_soup_http_src_set_location (GstSoupHTTPSrc * src, const gchar * uri,
+    GError ** error)
+{
+  const char *alt_schemes[] = { "icy://", "icyx://" };
+  guint i;
+
+  if (src->location) {
+    g_free (src->location);
+    src->location = NULL;
+  }
+
+  if (uri == NULL)
+    return FALSE;
+
+  for (i = 0; i < G_N_ELEMENTS (alt_schemes); i++) {
+    if (g_str_has_prefix (uri, alt_schemes[i])) {
+      src->location =
+          g_strdup_printf ("http://%s", uri + strlen (alt_schemes[i]));
+      return TRUE;
+    }
+  }
+
+  if (src->redirection_uri) {
+    g_free (src->redirection_uri);
+    src->redirection_uri = NULL;
+  }
+
+  src->location = g_strdup (uri);
+
+  return TRUE;
+}
+
+static gboolean
+gst_soup_http_src_set_proxy (GstSoupHTTPSrc * src, const gchar * uri)
+{
+  if (src->proxy) {
+    gst_soup_uri_free (src->proxy);
+    src->proxy = NULL;
+  }
+
+  if (uri == NULL || *uri == '\0')
+    return TRUE;
+
+  if (g_strstr_len (uri, -1, "://")) {
+    src->proxy = gst_soup_uri_new (uri);
+  } else {
+    gchar *new_uri = g_strconcat ("http://", uri, NULL);
+
+    src->proxy = gst_soup_uri_new (new_uri);
+    g_free (new_uri);
+  }
+
+  return (src->proxy != NULL);
+}
+
+static GstURIType
+gst_soup_http_src_uri_get_type (GType type)
+{
+  return GST_URI_SRC;
+}
+
+static const gchar *const *
+gst_soup_http_src_uri_get_protocols (GType type)
+{
+  static const gchar *protocols[] = { "http", "https", "icy", "icyx", NULL };
+
+  return protocols;
+}
+
+static gchar *
+gst_soup_http_src_uri_get_uri (GstURIHandler * handler)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (handler);
+
+  /* FIXME: make thread-safe */
+  return g_strdup (src->location);
+}
+
+static gboolean
+gst_soup_http_src_uri_set_uri (GstURIHandler * handler, const gchar * uri,
+    GError ** error)
+{
+  GstSoupHTTPSrc *src = GST_SOUP_HTTP_SRC (handler);
+
+  return gst_soup_http_src_set_location (src, uri, error);
+}
+
+static void
+gst_soup_http_src_uri_handler_init (gpointer g_iface, gpointer iface_data)
+{
+  GstURIHandlerInterface *iface = (GstURIHandlerInterface *) g_iface;
+
+  iface->get_type = gst_soup_http_src_uri_get_type;
+  iface->get_protocols = gst_soup_http_src_uri_get_protocols;
+  iface->get_uri = gst_soup_http_src_uri_get_uri;
+  iface->set_uri = gst_soup_http_src_uri_set_uri;
+}
+
+static gboolean
+souphttpsrc_element_init (GstPlugin * plugin)
+{
+  gboolean ret = TRUE;
+
+  GST_DEBUG_CATEGORY_INIT (souphttpsrc_debug, "souphttpsrc", 0,
+      "SOUP HTTP src");
+
+  if (!soup_element_init (plugin))
+    return TRUE;
+
+  ret = gst_element_register (plugin, "souphttpsrc",
+      GST_RANK_PRIMARY, GST_TYPE_SOUP_HTTP_SRC);
+
+  return ret;
+}
diff --git a/ext/soup3/gstsouphttpsrc.h b/ext/soup3/gstsouphttpsrc.h
new file mode 100644
index 0000000..8970594
--- /dev/null
+++ b/ext/soup3/gstsouphttpsrc.h
@@ -0,0 +1,138 @@
+/* GStreamer
+ * Copyright (C) 2007-2008 Wouter Cloetens <wouter@mind.be>
+ * Copyright (C) 2021 Igalia S.L.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more 
+ */
+
+#ifndef __GST_SOUP_HTTP_SRC_H__
+#define __GST_SOUP_HTTP_SRC_H__
+
+#include "gstsouputils.h"
+#include "gstsouploader.h"
+#include <gio/gio.h>
+#include <gst/base/gstpushsrc.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_SOUP_HTTP_SRC \
+  (gst_soup_http_src_get_type())
+#define GST_SOUP_HTTP_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SOUP_HTTP_SRC,GstSoupHTTPSrc))
+#define GST_SOUP_HTTP_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass), \
+      GST_TYPE_SOUP_HTTP_SRC,GstSoupHTTPSrcClass))
+#define GST_IS_SOUP_HTTP_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SOUP_HTTP_SRC))
+#define GST_IS_SOUP_HTTP_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SOUP_HTTP_SRC))
+
+typedef struct _GstSoupHTTPSrc GstSoupHTTPSrc;
+typedef struct _GstSoupHTTPSrcClass GstSoupHTTPSrcClass;
+
+typedef enum {
+  GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_IDLE,
+  GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_QUEUED,
+  GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_RUNNING,
+  GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_CANCELLED,
+} GstSoupHTTPSrcSessionIOStatus;
+
+/* opaque from here, implementation detail */
+typedef struct _GstSoupSession GstSoupSession;
+
+struct _GstSoupHTTPSrc {
+  GstPushSrc element;
+
+  gchar *location;             /* Full URI. */
+  gchar *redirection_uri;      /* Full URI after redirections. */
+  gboolean redirection_permanent; /* Permanent or temporary redirect? */
+  gchar *user_agent;           /* User-Agent HTTP header. */
+  gboolean automatic_redirect; /* Follow redirects. */
+  GstSoupUri *proxy;           /* HTTP proxy URI. */
+  gchar *user_id;              /* Authentication user id for location URI. */
+  gchar *user_pw;              /* Authentication user password for location URI. */
+  gchar *proxy_id;             /* Authentication user id for proxy URI. */
+  gchar *proxy_pw;             /* Authentication user password for proxy URI. */
+  gchar **cookies;             /* HTTP request cookies. */
+  GstSoupSession *session;     /* Libsoup session wrapper. */
+  gboolean session_is_shared;
+  GstSoupSession *external_session; /* Shared via GstContext */
+  SoupMessage *msg;            /* Request message. */
+  gint retry_count;            /* Number of retries since we received data */
+  gint max_retries;            /* Maximum number of retries */
+  gchar *method;               /* HTTP method */
+
+  GstFlowReturn headers_ret;
+  gboolean got_headers;        /* Already received headers from the server */
+  gboolean have_size;          /* Received and parsed Content-Length
+                                  header. */
+  guint64 content_size;        /* Value of Content-Length header. */
+  guint64 read_position;       /* Current position. */
+  gboolean seekable;           /* FALSE if the server does not support
+                                  Range. */
+  guint64 request_position;    /* Seek to this position. */
+  guint64 stop_position;       /* Stop at this position. */
+  gboolean have_body;          /* Indicates if it has just been signaled the
+                                * end of the message body. This is used to
+                                * decide if an out of range request should be
+                                * handled as an error or EOS when the content
+                                * size is unknown */
+  gboolean keep_alive;         /* Use keep-alive sessions */
+  gboolean ssl_strict;
+  gchar *ssl_ca_file;
+  gboolean ssl_use_system_ca_file;
+  GTlsDatabase *tls_database;
+  GTlsInteraction *tls_interaction;
+
+  GCancellable *cancellable;
+  GInputStream *input_stream;
+
+  gint reduce_blocksize_count;
+  gint increase_blocksize_count;
+  guint minimum_blocksize;
+
+  /* Shoutcast/icecast metadata extraction handling. */
+  gboolean iradio_mode;
+  GstCaps *src_caps;
+  gchar *iradio_name;
+  gchar *iradio_genre;
+  gchar *iradio_url;
+
+  GstStructure *extra_headers;
+
+  SoupLoggerLogLevel log_level;/* Soup HTTP session logger level */
+
+  gboolean compress;
+
+  guint timeout;
+
+  /* This mutex-cond pair is used to talk to the soup session thread; it is
+   * per src to allow concurrent access to shared sessions (if it was inside
+   * the shared session structure, it would be effectively global)
+   */
+  GMutex session_mutex;
+  GCond session_cond;
+
+  GstEvent *http_headers_event;
+
+  gint64 last_socket_read_time;
+};
+
+struct _GstSoupHTTPSrcClass {
+  GstPushSrcClass parent_class;
+};
+
+GType gst_soup_http_src_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_SOUP_HTTP_SRC_H__ */
+
diff --git a/ext/soup3/gstsouploader.c b/ext/soup3/gstsouploader.c
new file mode 100644
index 0000000..b65cfda
--- /dev/null
+++ b/ext/soup3/gstsouploader.c
@@ -0,0 +1,939 @@
+/* GStreamer
+ * Copyright (C) 2021 Igalia S.L.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstsouploader.h"
+#include <gmodule.h>
+
+#ifdef HAVE_RTLD_NOLOAD
+#include <dlfcn.h>
+#endif
+
+#ifdef G_OS_WIN32
+#include <windows.h>
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+#define GST_WINAPI_ONLY_APP
+#endif
+#endif /* G_OS_WIN32 */
+
+#ifdef BUILDING_ADAPTIVEDEMUX2
+GST_DEBUG_CATEGORY (gst_adaptivedemux_soup_debug);
+#define GST_CAT_DEFAULT gst_adaptivedemux_soup_debug
+#else
+GST_DEBUG_CATEGORY (gst_soup_debug);
+#define GST_CAT_DEFAULT gst_soup_debug
+#endif
+
+
+#ifndef STATIC_SOUP
+
+/* G_OS_WIN32 is handled separately below */
+#ifdef __APPLE__
+#define LIBSOUP_3_SONAME "libsoup-3.0.0.dylib"
+#define LIBSOUP_2_SONAME "libsoup-2.4.1.dylib"
+#else
+#define LIBSOUP_3_SONAME "libsoup-3.0.so.0"
+#define LIBSOUP_2_SONAME "libsoup-2.4.so.1"
+#endif
+
+
+#define LOAD_SYMBOL(name) G_STMT_START {                                \
+    if (!g_module_symbol (module, G_STRINGIFY (name), (gpointer *) &G_PASTE (vtable->_, name))) { \
+      GST_ERROR ("Failed to load '%s' from %s, %s", G_STRINGIFY (name), g_module_name (module), g_module_error()); \
+      goto error;                                                       \
+    }                                                                   \
+  } G_STMT_END;
+
+#define LOAD_VERSIONED_SYMBOL(version, name) G_STMT_START {             \
+  if (!g_module_symbol(module, G_STRINGIFY(name), (gpointer *)&G_PASTE(vtable->_, G_PASTE(name, G_PASTE(_, version))))) { \
+    GST_WARNING ("Failed to load '%s' from %s, %s", G_STRINGIFY(name),  \
+                g_module_name(module), g_module_error());               \
+    goto error;                                                         \
+  }                                                                     \
+  } G_STMT_END;
+
+typedef struct _GstSoupVTable
+{
+  gboolean loaded;
+  guint lib_version;
+
+  /* *INDENT-OFF* */
+
+  /* Symbols present only in libsoup 3 */
+#if GLIB_CHECK_VERSION(2, 66, 0)
+  GUri *(*_soup_message_get_uri_3)(SoupMessage * msg);
+#endif
+  SoupLogger *(*_soup_logger_new_3) (SoupLoggerLogLevel level);
+  SoupMessageHeaders *(*_soup_message_get_request_headers_3) (SoupMessage * msg);
+  SoupMessageHeaders *(*_soup_message_get_response_headers_3) (SoupMessage * msg);
+  void (*_soup_message_set_request_body_from_bytes_3) (SoupMessage * msg,
+    const char * content_type, GBytes * data);
+  const char *(*_soup_message_get_reason_phrase_3) (SoupMessage * msg);
+  SoupStatus (*_soup_message_get_status_3) (SoupMessage * msg);
+
+  /* Symbols present only in libsoup 2 */
+  SoupLogger *(*_soup_logger_new_2) (SoupLoggerLogLevel, int);
+  SoupURI *(*_soup_uri_new_2) (const char *);
+  SoupURI *(*_soup_message_get_uri_2) (SoupMessage *);
+  char *(*_soup_uri_to_string_2) (SoupURI *, gboolean);
+  void (*_soup_message_body_append_2) (SoupMessageBody *, SoupMemoryUse,
+    gconstpointer, gsize);
+  void (*_soup_uri_free_2) (SoupURI *);
+  void (*_soup_session_cancel_message_2) (SoupSession *, SoupMessage *, guint);
+
+  /* Symbols present in libsoup 2 and libsoup 3 */
+  GType (*_soup_content_decoder_get_type) (void);
+  GType (*_soup_cookie_jar_get_type) (void);
+  guint (*_soup_get_major_version) (void);
+  guint (*_soup_get_minor_version) (void);
+  guint (*_soup_get_micro_version) (void);
+  GType (*_soup_logger_log_level_get_type) (void);
+  void (*_soup_logger_set_printer) (SoupLogger * logger, SoupLoggerPrinter printer, gpointer user_data,
+    GDestroyNotify destroy_notify);
+  void (*_soup_message_disable_feature) (SoupMessage * message, GType feature_type);
+  void (*_soup_message_headers_append) (SoupMessageHeaders * hdrs, const char * name,
+    const char * value);
+  void (*_soup_message_headers_foreach) (SoupMessageHeaders * hdrs,
+    SoupMessageHeadersForeachFunc callback, gpointer user_data);
+  goffset (*_soup_message_headers_get_content_length) (SoupMessageHeaders * hdrs);
+  const char *(*_soup_message_headers_get_content_type) (SoupMessageHeaders * hdrs,
+    GHashTable ** value);
+  gboolean (*_soup_message_headers_get_content_range) (SoupMessageHeaders *hdrs, goffset *start,
+    goffset *end, goffset *total_length);
+  void (*_soup_message_headers_set_range) (SoupMessageHeaders *hdrs, goffset start, goffset end);
+  SoupEncoding (*_soup_message_headers_get_encoding) (SoupMessageHeaders * hdrs);
+  const char *(*_soup_message_headers_get_one) (SoupMessageHeaders * hdrs,
+    const char * name);
+  void (*_soup_message_headers_remove) (SoupMessageHeaders * hdrs, const char * name);
+  SoupMessage *(*_soup_message_new) (const char * method, const char * location);
+  void (*_soup_message_set_flags) (SoupMessage * msg, SoupMessageFlags flags);
+  void (*_soup_session_abort) (SoupSession * session);
+  void (*_soup_session_add_feature) (SoupSession * session, SoupSessionFeature * feature);
+  void (*_soup_session_add_feature_by_type) (SoupSession * session, GType feature_type);
+  GType (*_soup_session_get_type) (void);
+
+  void (*_soup_auth_authenticate) (SoupAuth * auth, const char *username,
+    const char *password);
+  const char *(*_soup_message_get_method_3) (SoupMessage * msg);
+  GInputStream *(*_soup_session_send_async_2) (SoupSession * session, SoupMessage * msg,
+    GCancellable * cancellable, GAsyncReadyCallback callback, gpointer user_data);
+  GInputStream *(*_soup_session_send_async_3) (SoupSession * session, SoupMessage * msg,
+    int io_priority, GCancellable * cancellable, GAsyncReadyCallback callback, gpointer user_data);
+  GInputStream *(*_soup_session_send_finish) (SoupSession * session,
+    GAsyncResult * result, GError ** error);
+  GInputStream *(*_soup_session_send) (SoupSession * session, SoupMessage * msg,
+    GCancellable * cancellable, GError ** error);
+  /* *INDENT-ON* */
+} GstSoupVTable;
+
+static GstSoupVTable gst_soup_vtable = { 0, };
+
+gboolean
+gst_soup_load_library (void)
+{
+  GModule *module;
+  GstSoupVTable *vtable;
+  const gchar *libsoup_sonames[5] = { 0 };
+  guint len = 0;
+
+  if (gst_soup_vtable.loaded)
+    return TRUE;
+
+  g_assert (g_module_supported ());
+
+#ifdef BUILDING_ADAPTIVEDEMUX2
+  GST_DEBUG_CATEGORY_INIT (gst_adaptivedemux_soup_debug, "adaptivedemux2-soup",
+      0, "adaptivedemux2-soup");
+#else
+  GST_DEBUG_CATEGORY_INIT (gst_soup_debug, "soup", 0, "soup");
+#endif
+
+#ifdef HAVE_RTLD_NOLOAD
+  {
+    gpointer handle = NULL;
+
+    /* In order to avoid causing conflicts we detect if libsoup 2 or 3 is loaded already.
+     * If so use that. Otherwise we will try to load our own version to use preferring 3. */
+
+    if ((handle = dlopen (LIBSOUP_3_SONAME, RTLD_NOW | RTLD_NOLOAD))) {
+      libsoup_sonames[0] = LIBSOUP_3_SONAME;
+      GST_DEBUG ("LibSoup 3 found");
+    } else if ((handle = dlopen (LIBSOUP_2_SONAME, RTLD_NOW | RTLD_NOLOAD))) {
+      libsoup_sonames[0] = LIBSOUP_2_SONAME;
+      GST_DEBUG ("LibSoup 2 found");
+    } else {
+      GST_DEBUG ("Trying all libsoups");
+      libsoup_sonames[0] = LIBSOUP_3_SONAME;
+      libsoup_sonames[1] = LIBSOUP_2_SONAME;
+    }
+
+    g_clear_pointer (&handle, dlclose);
+  }
+#else /* !HAVE_RTLD_NOLOAD */
+
+#ifdef G_OS_WIN32
+
+#define LIBSOUP2_MSVC_DLL "soup-2.4-1.dll"
+#define LIBSOUP3_MSVC_DLL "soup-3.0-0.dll"
+#define LIBSOUP2_MINGW_DLL "libsoup-2.4-1.dll"
+#define LIBSOUP3_MINGW_DLL "libsoup-3.0-0.dll"
+
+  {
+#ifdef _MSC_VER
+    const char *candidates[5] = { LIBSOUP3_MSVC_DLL, LIBSOUP2_MSVC_DLL,
+      LIBSOUP3_MINGW_DLL, LIBSOUP2_MINGW_DLL, 0
+    };
+#else
+    const char *candidates[5] = { LIBSOUP3_MINGW_DLL, LIBSOUP2_MINGW_DLL,
+      LIBSOUP3_MSVC_DLL, LIBSOUP2_MSVC_DLL, 0
+    };
+#endif /* _MSC_VER */
+
+    guint len = g_strv_length ((gchar **) candidates);
+#if !GST_WINAPI_ONLY_APP
+    for (guint i = 0; i < len; i++) {
+      HMODULE phModule;
+      BOOL loaded =
+          GetModuleHandleExA (GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+          candidates[i], &phModule);
+      if (loaded) {
+        GST_DEBUG ("%s is resident. Using it.", candidates[i]);
+        libsoup_sonames[0] = candidates[i];
+        break;
+      }
+    }
+#endif
+    if (libsoup_sonames[0] == NULL) {
+      GST_DEBUG ("No resident libsoup, trying them all");
+      for (guint i = 0; i < len; i++) {
+        libsoup_sonames[i] = candidates[i];
+      }
+    }
+  }
+#else /* !G_OS_WIN32 */
+  libsoup_sonames[0] = LIBSOUP_3_SONAME;
+  libsoup_sonames[1] = LIBSOUP_2_SONAME;
+#endif /* G_OS_WIN32 */
+
+#endif /* HAVE_RTLD_NOLOAD */
+
+  vtable = &gst_soup_vtable;
+  len = g_strv_length ((gchar **) libsoup_sonames);
+
+  for (guint i = 0; i < len; i++) {
+    module =
+        g_module_open (libsoup_sonames[i],
+        G_MODULE_BIND_LAZY | G_MODULE_BIND_LOCAL);
+    if (module) {
+      GST_DEBUG ("Loaded %s", g_module_name (module));
+      if (g_strstr_len (libsoup_sonames[i], -1, "soup-2")) {
+        vtable->lib_version = 2;
+        LOAD_VERSIONED_SYMBOL (2, soup_logger_new);
+        LOAD_VERSIONED_SYMBOL (2, soup_message_body_append);
+        LOAD_VERSIONED_SYMBOL (2, soup_uri_free);
+        LOAD_VERSIONED_SYMBOL (2, soup_uri_new);
+        LOAD_VERSIONED_SYMBOL (2, soup_uri_to_string);
+        LOAD_VERSIONED_SYMBOL (2, soup_message_get_uri);
+        LOAD_VERSIONED_SYMBOL (2, soup_session_cancel_message);
+        LOAD_VERSIONED_SYMBOL (2, soup_session_send_async);
+      } else {
+        vtable->lib_version = 3;
+        LOAD_VERSIONED_SYMBOL (3, soup_logger_new);
+        LOAD_VERSIONED_SYMBOL (3, soup_message_get_request_headers);
+        LOAD_VERSIONED_SYMBOL (3, soup_message_get_response_headers);
+        LOAD_VERSIONED_SYMBOL (3, soup_message_set_request_body_from_bytes);
+#if GLIB_CHECK_VERSION(2, 66, 0)
+        LOAD_VERSIONED_SYMBOL (3, soup_message_get_uri);
+#endif
+        LOAD_VERSIONED_SYMBOL (3, soup_message_get_method);
+        LOAD_VERSIONED_SYMBOL (3, soup_message_get_reason_phrase);
+        LOAD_VERSIONED_SYMBOL (3, soup_message_get_status);
+        LOAD_VERSIONED_SYMBOL (3, soup_session_send_async);
+      }
+
+      LOAD_SYMBOL (soup_auth_authenticate);
+      LOAD_SYMBOL (soup_content_decoder_get_type);
+      LOAD_SYMBOL (soup_cookie_jar_get_type);
+      LOAD_SYMBOL (soup_get_major_version);
+      LOAD_SYMBOL (soup_get_micro_version);
+      LOAD_SYMBOL (soup_get_minor_version);
+      LOAD_SYMBOL (soup_logger_log_level_get_type);
+      LOAD_SYMBOL (soup_logger_set_printer);
+      LOAD_SYMBOL (soup_message_disable_feature);
+      LOAD_SYMBOL (soup_message_headers_append);
+      LOAD_SYMBOL (soup_message_headers_foreach);
+      LOAD_SYMBOL (soup_message_headers_get_content_length);
+      LOAD_SYMBOL (soup_message_headers_get_content_type);
+      LOAD_SYMBOL (soup_message_headers_get_content_range);
+      LOAD_SYMBOL (soup_message_headers_set_range);
+      LOAD_SYMBOL (soup_message_headers_get_encoding);
+      LOAD_SYMBOL (soup_message_headers_get_one);
+      LOAD_SYMBOL (soup_message_headers_remove);
+      LOAD_SYMBOL (soup_message_new);
+      LOAD_SYMBOL (soup_message_set_flags);
+      LOAD_SYMBOL (soup_session_abort);
+      LOAD_SYMBOL (soup_session_add_feature);
+      LOAD_SYMBOL (soup_session_add_feature_by_type);
+      LOAD_SYMBOL (soup_session_get_type);
+      LOAD_SYMBOL (soup_session_send);
+      LOAD_SYMBOL (soup_session_send_finish);
+
+      vtable->loaded = TRUE;
+      goto beach;
+
+    error:
+      GST_DEBUG ("Failed to find all libsoup symbols");
+      g_clear_pointer (&module, g_module_close);
+      continue;
+    } else {
+      GST_DEBUG ("Module %s not found", libsoup_sonames[i]);
+      continue;
+    }
+  beach:
+    break;
+  }
+
+  return vtable->loaded;
+}
+
+#endif /* !STATIC_SOUP */
+
+guint
+gst_soup_loader_get_api_version (void)
+{
+#ifdef STATIC_SOUP
+  return STATIC_SOUP;
+#else
+  return gst_soup_vtable.lib_version;
+#endif
+}
+
+SoupSession *
+_soup_session_new_with_options (const char *optname1, ...)
+{
+  SoupSession *session;
+  va_list ap;
+
+  va_start (ap, optname1);
+  session =
+      (SoupSession *) g_object_new_valist (_soup_session_get_type (), optname1,
+      ap);
+  va_end (ap);
+  return session;
+}
+
+SoupLogger *
+_soup_logger_new (SoupLoggerLogLevel level)
+{
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 2
+  return soup_logger_new (level, -1);
+#elif STATIC_SOUP == 3
+  return soup_logger_new (level);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 2) {
+    g_assert (gst_soup_vtable._soup_logger_new_2 != NULL);
+    return gst_soup_vtable._soup_logger_new_2 (level, -1);
+  }
+  g_assert (gst_soup_vtable._soup_logger_new_3 != NULL);
+  return gst_soup_vtable._soup_logger_new_3 (level);
+#endif
+}
+
+void
+_soup_logger_set_printer (SoupLogger * logger, SoupLoggerPrinter printer,
+    gpointer printer_data, GDestroyNotify destroy)
+{
+#ifdef STATIC_SOUP
+  soup_logger_set_printer (logger, printer, printer_data, destroy);
+#else
+  g_assert (gst_soup_vtable._soup_logger_set_printer != NULL);
+  gst_soup_vtable._soup_logger_set_printer (logger, printer, printer_data,
+      destroy);
+#endif
+}
+
+void
+_soup_session_add_feature (SoupSession * session, SoupSessionFeature * feature)
+{
+#ifdef STATIC_SOUP
+  soup_session_add_feature (session, feature);
+#else
+  g_assert (gst_soup_vtable._soup_session_add_feature != NULL);
+  gst_soup_vtable._soup_session_add_feature (session, feature);
+#endif
+}
+
+GstSoupUri *
+gst_soup_uri_new (const char *uri_string)
+{
+  GstSoupUri *uri = g_new0 (GstSoupUri, 1);
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 2
+  uri->soup_uri = soup_uri_new (uri_string);
+#else
+  uri->uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 2) {
+    g_assert (gst_soup_vtable._soup_uri_new_2 != NULL);
+    uri->soup_uri = gst_soup_vtable._soup_uri_new_2 (uri_string);
+  } else {
+#if GLIB_CHECK_VERSION(2, 66, 0)
+    uri->uri = g_uri_parse (uri_string, SOUP_HTTP_URI_FLAGS, NULL);
+#endif
+  }
+#endif
+  return uri;
+}
+
+void
+gst_soup_uri_free (GstSoupUri * uri)
+{
+#if (defined(STATIC_SOUP) && STATIC_SOUP == 3) || (!defined(STATIC_SOUP) && GLIB_CHECK_VERSION(2, 66, 0))
+  if (uri->uri) {
+    g_uri_unref (uri->uri);
+  }
+#endif
+
+#if defined(STATIC_SOUP)
+#if STATIC_SOUP == 2
+  if (uri->soup_uri) {
+    soup_uri_free (uri->soup_uri);
+  }
+#endif
+#else /* !STATIC_SOUP */
+  if (uri->soup_uri) {
+    g_assert (gst_soup_vtable._soup_uri_free_2 != NULL);
+    gst_soup_vtable._soup_uri_free_2 (uri->soup_uri);
+  }
+#endif /* STATIC_SOUP */
+  g_free (uri);
+}
+
+char *
+gst_soup_uri_to_string (GstSoupUri * uri)
+{
+#if (defined(STATIC_SOUP) && STATIC_SOUP == 3) || (!defined(STATIC_SOUP) && GLIB_CHECK_VERSION(2, 66, 0))
+  if (uri->uri) {
+    return g_uri_to_string_partial (uri->uri, G_URI_HIDE_PASSWORD);
+  }
+#endif
+
+#if defined(STATIC_SOUP)
+#if STATIC_SOUP == 2
+  if (uri->soup_uri) {
+    return soup_uri_to_string (uri->soup_uri, FALSE);
+  }
+#endif
+#else /* !STATIC_SOUP */
+  if (uri->soup_uri) {
+    g_assert (gst_soup_vtable._soup_uri_to_string_2 != NULL);
+    return gst_soup_vtable._soup_uri_to_string_2 (uri->soup_uri, FALSE);
+  }
+#endif /* STATIC_SOUP */
+
+  g_assert_not_reached ();
+  return NULL;
+}
+
+char *
+gst_soup_message_uri_to_string (SoupMessage * msg)
+{
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 2
+  SoupURI *uri = NULL;
+  uri = soup_message_get_uri (msg);
+  return soup_uri_to_string (uri, FALSE);
+#elif STATIC_SOUP == 3
+  GUri *uri = NULL;
+  uri = soup_message_get_uri (msg);
+  return g_uri_to_string_partial (uri, G_URI_HIDE_PASSWORD);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 2) {
+    SoupURI *uri = NULL;
+    g_assert (gst_soup_vtable._soup_message_get_uri_2 != NULL);
+    uri = gst_soup_vtable._soup_message_get_uri_2 (msg);
+    return gst_soup_vtable._soup_uri_to_string_2 (uri, FALSE);
+  } else {
+#if GLIB_CHECK_VERSION(2, 66, 0)
+    GUri *uri = NULL;
+    g_assert (gst_soup_vtable._soup_message_get_uri_3 != NULL);
+    uri = gst_soup_vtable._soup_message_get_uri_3 (msg);
+    return g_uri_to_string_partial (uri, G_URI_HIDE_PASSWORD);
+#endif
+  }
+#endif
+  /*
+   * If we reach this, it means the plugin was built for old glib, but somehow
+   * we managed to load libsoup3, which requires a very recent glib. As this
+   * is a contradiction, we can assert, I guess?
+   */
+  g_assert_not_reached ();
+  return NULL;
+}
+
+guint
+_soup_get_major_version (void)
+{
+#ifdef STATIC_SOUP
+  return soup_get_major_version ();
+#else
+  g_assert (gst_soup_vtable._soup_get_major_version != NULL);
+  return gst_soup_vtable._soup_get_major_version ();
+#endif
+}
+
+guint
+_soup_get_minor_version (void)
+{
+#ifdef STATIC_SOUP
+  return soup_get_minor_version ();
+#else
+  g_assert (gst_soup_vtable._soup_get_minor_version != NULL);
+  return gst_soup_vtable._soup_get_minor_version ();
+#endif
+}
+
+guint
+_soup_get_micro_version (void)
+{
+#ifdef STATIC_SOUP
+  return soup_get_micro_version ();
+#else
+  g_assert (gst_soup_vtable._soup_get_micro_version != NULL);
+  return gst_soup_vtable._soup_get_micro_version ();
+#endif
+}
+
+void
+_soup_message_set_request_body_from_bytes (SoupMessage * msg,
+    const char *content_type, GBytes * bytes)
+{
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 2
+  gsize size;
+  gconstpointer data = g_bytes_get_data (bytes, &size);
+  soup_message_body_append (msg->request_body, SOUP_MEMORY_COPY, data, size);
+#elif STATIC_SOUP == 3
+  soup_message_set_request_body_from_bytes (msg, content_type, bytes);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 3) {
+    g_assert (gst_soup_vtable._soup_message_set_request_body_from_bytes_3 !=
+        NULL);
+    gst_soup_vtable._soup_message_set_request_body_from_bytes_3 (msg,
+        content_type, bytes);
+  } else {
+    gsize size;
+    gconstpointer data = g_bytes_get_data (bytes, &size);
+    SoupMessage2 *msg2 = (SoupMessage2 *) msg;
+    g_assert (gst_soup_vtable._soup_message_body_append_2 != NULL);
+    gst_soup_vtable._soup_message_body_append_2 (msg2->request_body,
+        SOUP_MEMORY_COPY, data, size);
+  }
+#endif
+}
+
+GType
+_soup_session_get_type (void)
+{
+#ifdef STATIC_SOUP
+  return soup_session_get_type ();
+#else
+  g_assert (gst_soup_vtable._soup_session_get_type != NULL);
+  return gst_soup_vtable._soup_session_get_type ();
+#endif
+}
+
+GType
+_soup_logger_log_level_get_type (void)
+{
+#ifdef STATIC_SOUP
+  return soup_logger_log_level_get_type ();
+#else
+  g_assert (gst_soup_vtable._soup_logger_log_level_get_type != NULL);
+  return gst_soup_vtable._soup_logger_log_level_get_type ();
+#endif
+}
+
+GType
+_soup_content_decoder_get_type (void)
+{
+#ifdef STATIC_SOUP
+  return soup_content_decoder_get_type ();
+#else
+  g_assert (gst_soup_vtable._soup_content_decoder_get_type != NULL);
+  return gst_soup_vtable._soup_content_decoder_get_type ();
+#endif
+}
+
+GType
+_soup_cookie_jar_get_type (void)
+{
+#ifdef STATIC_SOUP
+  return soup_cookie_jar_get_type ();
+#else
+  g_assert (gst_soup_vtable._soup_cookie_jar_get_type != NULL);
+  return gst_soup_vtable._soup_cookie_jar_get_type ();
+#endif
+}
+
+void
+_soup_session_abort (SoupSession * session)
+{
+#ifdef STATIC_SOUP
+  soup_session_abort (session);
+#else
+  g_assert (gst_soup_vtable._soup_session_abort != NULL);
+  gst_soup_vtable._soup_session_abort (session);
+#endif
+}
+
+SoupMessage *
+_soup_message_new (const char *method, const char *uri_string)
+{
+#ifdef STATIC_SOUP
+  return soup_message_new (method, uri_string);
+#else
+  g_assert (gst_soup_vtable._soup_message_new != NULL);
+  return gst_soup_vtable._soup_message_new (method, uri_string);
+#endif
+}
+
+SoupMessageHeaders *
+_soup_message_get_request_headers (SoupMessage * msg)
+{
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 2
+  return msg->request_headers;
+#elif STATIC_SOUP == 3
+  return soup_message_get_request_headers (msg);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 3) {
+    g_assert (gst_soup_vtable._soup_message_get_request_headers_3 != NULL);
+    return gst_soup_vtable._soup_message_get_request_headers_3 (msg);
+  } else {
+    SoupMessage2 *msg2 = (SoupMessage2 *) msg;
+    return msg2->request_headers;
+  }
+#endif
+}
+
+SoupMessageHeaders *
+_soup_message_get_response_headers (SoupMessage * msg)
+{
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 2
+  return msg->response_headers;
+#elif STATIC_SOUP == 3
+  return soup_message_get_response_headers (msg);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 3) {
+    g_assert (gst_soup_vtable._soup_message_get_response_headers_3 != NULL);
+    return gst_soup_vtable._soup_message_get_response_headers_3 (msg);
+  } else {
+    SoupMessage2 *msg2 = (SoupMessage2 *) msg;
+    return msg2->response_headers;
+  }
+#endif
+}
+
+void
+_soup_message_headers_remove (SoupMessageHeaders * hdrs, const char *name)
+{
+#ifdef STATIC_SOUP
+  soup_message_headers_remove (hdrs, name);
+#else
+  g_assert (gst_soup_vtable._soup_message_headers_remove != NULL);
+  gst_soup_vtable._soup_message_headers_remove (hdrs, name);
+#endif
+}
+
+void
+_soup_message_headers_append (SoupMessageHeaders * hdrs, const char *name,
+    const char *value)
+{
+#ifdef STATIC_SOUP
+  soup_message_headers_append (hdrs, name, value);
+#else
+  g_assert (gst_soup_vtable._soup_message_headers_append != NULL);
+  gst_soup_vtable._soup_message_headers_append (hdrs, name, value);
+#endif
+}
+
+void
+_soup_message_set_flags (SoupMessage * msg, SoupMessageFlags flags)
+{
+#ifdef STATIC_SOUP
+  soup_message_set_flags (msg, flags);
+#else
+  g_assert (gst_soup_vtable._soup_message_set_flags != NULL);
+  gst_soup_vtable._soup_message_set_flags (msg, flags);
+#endif
+}
+
+void
+_soup_session_add_feature_by_type (SoupSession * session, GType feature_type)
+{
+#ifdef STATIC_SOUP
+  soup_session_add_feature_by_type (session, feature_type);
+#else
+  g_assert (gst_soup_vtable._soup_session_add_feature_by_type != NULL);
+  gst_soup_vtable._soup_session_add_feature_by_type (session, feature_type);
+#endif
+}
+
+void
+_soup_message_headers_foreach (SoupMessageHeaders * hdrs,
+    SoupMessageHeadersForeachFunc func, gpointer user_data)
+{
+#ifdef STATIC_SOUP
+  soup_message_headers_foreach (hdrs, func, user_data);
+#else
+  g_assert (gst_soup_vtable._soup_message_headers_foreach != NULL);
+  gst_soup_vtable._soup_message_headers_foreach (hdrs, func, user_data);
+#endif
+}
+
+SoupEncoding
+_soup_message_headers_get_encoding (SoupMessageHeaders * hdrs)
+{
+#ifdef STATIC_SOUP
+  return soup_message_headers_get_encoding (hdrs);
+#else
+  g_assert (gst_soup_vtable._soup_message_headers_get_encoding != NULL);
+  return gst_soup_vtable._soup_message_headers_get_encoding (hdrs);
+#endif
+}
+
+goffset
+_soup_message_headers_get_content_length (SoupMessageHeaders * hdrs)
+{
+#ifdef STATIC_SOUP
+  return soup_message_headers_get_content_length (hdrs);
+#else
+  g_assert (gst_soup_vtable._soup_message_headers_get_content_length != NULL);
+  return gst_soup_vtable._soup_message_headers_get_content_length (hdrs);
+#endif
+}
+
+SoupStatus
+_soup_message_get_status (SoupMessage * msg)
+{
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 2
+  return msg->status_code;
+#elif STATIC_SOUP == 3
+  return soup_message_get_status (msg);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 3) {
+    g_assert (gst_soup_vtable._soup_message_get_status_3 != NULL);
+    return gst_soup_vtable._soup_message_get_status_3 (msg);
+  } else {
+    SoupMessage2 *msg2 = (SoupMessage2 *) msg;
+    return msg2->status_code;
+  }
+#endif
+}
+
+const char *
+_soup_message_get_reason_phrase (SoupMessage * msg)
+{
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 2
+  return msg->reason_phrase;
+#elif STATIC_SOUP == 3
+  return soup_message_get_reason_phrase (msg);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 3) {
+    g_assert (gst_soup_vtable._soup_message_get_reason_phrase_3 != NULL);
+    return gst_soup_vtable._soup_message_get_reason_phrase_3 (msg);
+  } else {
+    SoupMessage2 *msg2 = (SoupMessage2 *) msg;
+    return msg2->reason_phrase;
+  }
+#endif
+}
+
+const char *
+_soup_message_headers_get_one (SoupMessageHeaders * hdrs, const char *name)
+{
+#ifdef STATIC_SOUP
+  return soup_message_headers_get_one (hdrs, name);
+#else
+  g_assert (gst_soup_vtable._soup_message_headers_get_one != NULL);
+  return gst_soup_vtable._soup_message_headers_get_one (hdrs, name);
+#endif
+}
+
+void
+_soup_message_disable_feature (SoupMessage * msg, GType feature_type)
+{
+#ifdef STATIC_SOUP
+  soup_message_disable_feature (msg, feature_type);
+#else
+  g_assert (gst_soup_vtable._soup_message_disable_feature != NULL);
+  gst_soup_vtable._soup_message_disable_feature (msg, feature_type);
+#endif
+}
+
+const char *
+_soup_message_headers_get_content_type (SoupMessageHeaders * hdrs,
+    GHashTable ** params)
+{
+#ifdef STATIC_SOUP
+  return soup_message_headers_get_content_type (hdrs, params);
+#else
+  g_assert (gst_soup_vtable._soup_message_headers_get_content_type != NULL);
+  return gst_soup_vtable._soup_message_headers_get_content_type (hdrs, params);
+#endif
+}
+
+gboolean
+_soup_message_headers_get_content_range (SoupMessageHeaders * hdrs,
+    goffset * start, goffset * end, goffset * total_length)
+{
+#ifdef STATIC_SOUP
+  return soup_message_headers_get_content_range (hdrs, start, end,
+      total_length);
+#else
+  g_assert (gst_soup_vtable._soup_message_headers_get_content_range != NULL);
+  return gst_soup_vtable._soup_message_headers_get_content_range (hdrs, start,
+      end, total_length);
+#endif
+}
+
+void
+_soup_message_headers_set_range (SoupMessageHeaders * hdrs, goffset start,
+    goffset end)
+{
+#ifdef STATIC_SOUP
+  soup_message_headers_set_range (hdrs, start, end);
+#else
+  g_assert (gst_soup_vtable._soup_message_headers_set_range != NULL);
+  gst_soup_vtable._soup_message_headers_set_range (hdrs, start, end);
+#endif
+}
+
+void
+_soup_auth_authenticate (SoupAuth * auth, const char *username,
+    const char *password)
+{
+#ifdef STATIC_SOUP
+  soup_auth_authenticate (auth, username, password);
+#else
+  g_assert (gst_soup_vtable._soup_auth_authenticate != NULL);
+  gst_soup_vtable._soup_auth_authenticate (auth, username, password);
+#endif
+}
+
+const char *
+_soup_message_get_method (SoupMessage * msg)
+{
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 2
+  return msg->method;
+#elif STATIC_SOUP == 3
+  return soup_message_get_method (msg);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 3) {
+    g_assert (gst_soup_vtable._soup_message_get_method_3 != NULL);
+    return gst_soup_vtable._soup_message_get_method_3 (msg);
+  } else {
+    SoupMessage2 *msg2 = (SoupMessage2 *) msg;
+    return msg2->method;
+  }
+#endif
+}
+
+void
+_soup_session_send_async (SoupSession * session, SoupMessage * msg,
+    GCancellable * cancellable, GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 2
+  soup_session_send_async (session, msg, cancellable, callback, user_data);
+#else
+  soup_session_send_async (session, msg, G_PRIORITY_DEFAULT, cancellable,
+      callback, user_data);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 3) {
+    g_assert (gst_soup_vtable._soup_session_send_async_3 != NULL);
+    gst_soup_vtable._soup_session_send_async_3 (session, msg,
+        G_PRIORITY_DEFAULT, cancellable, callback, user_data);
+  } else {
+    g_assert (gst_soup_vtable._soup_session_send_async_2 != NULL);
+    gst_soup_vtable._soup_session_send_async_2 (session, msg,
+        cancellable, callback, user_data);
+  }
+#endif
+}
+
+GInputStream *
+_soup_session_send_finish (SoupSession * session,
+    GAsyncResult * result, GError ** error)
+{
+#ifdef STATIC_SOUP
+  return soup_session_send_finish (session, result, error);
+#else
+  g_assert (gst_soup_vtable._soup_session_send_finish != NULL);
+  return gst_soup_vtable._soup_session_send_finish (session, result, error);
+#endif
+}
+
+GInputStream *
+_soup_session_send (SoupSession * session, SoupMessage * msg,
+    GCancellable * cancellable, GError ** error)
+{
+#ifdef STATIC_SOUP
+  return soup_session_send (session, msg, cancellable, error);
+#else
+  g_assert (gst_soup_vtable._soup_session_send != NULL);
+  return gst_soup_vtable._soup_session_send (session, msg, cancellable, error);
+#endif
+}
+
+void
+gst_soup_session_cancel_message (SoupSession * session, SoupMessage * msg,
+    GCancellable * cancellable)
+{
+#ifdef STATIC_SOUP
+#if STATIC_SOUP == 3
+  g_cancellable_cancel (cancellable);
+#else
+  soup_session_cancel_message (session, msg, SOUP_STATUS_CANCELLED);
+#endif
+#else
+  if (gst_soup_vtable.lib_version == 3) {
+    g_cancellable_cancel (cancellable);
+  } else {
+    g_assert (gst_soup_vtable._soup_session_cancel_message_2 != NULL);
+    gst_soup_vtable._soup_session_cancel_message_2 (session, msg,
+        SOUP_STATUS_CANCELLED);
+  }
+#endif
+}
diff --git a/ext/soup3/gstsouploader.h b/ext/soup3/gstsouploader.h
new file mode 100644
index 0000000..278adff
--- /dev/null
+++ b/ext/soup3/gstsouploader.h
@@ -0,0 +1,172 @@
+/* GStreamer
+ * Copyright (C) 2021 Igalia S.L.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+#ifndef __GST_SOUP_LOADER_H__
+#define __GST_SOUP_LOADER_H__
+
+#ifdef STATIC_SOUP
+#include <libsoup/soup.h>
+#else
+#include "stub/soup.h"
+#endif
+
+#include <gst/gst.h>
+#include <gio/gio.h>
+
+/* Prevent conflicting symbols when building both soup and adaptivedemux2 */
+#ifdef BUILDING_ADAPTIVEDEMUX2
+#define gst_soup_loader_get_api_version ad2_gst_soup_loader_get_api_version
+#define _soup_session_new_with_options _ad2_soup_session_new_with_options
+#define _soup_logger_new _ad2_soup_logger_new
+#define _soup_logger_set_printer _ad2_soup_logger_set_printer
+#define _soup_session_add_feature _ad2_soup_session_add_feature
+#define _soup_session_add_feature_by_type _ad2_soup_session_add_feature_by_type
+#define gst_soup_uri_new ad2_gst_soup_uri_new
+#define gst_soup_uri_free ad2_gst_soup_uri_free
+#define gst_soup_uri_to_string ad2_gst_soup_uri_to_string
+#define gst_soup_message_uri_to_string ad2_gst_soup_message_uri_to_string
+#define _soup_get_major_version _ad2_soup_get_major_version
+#define _soup_get_minor_version _ad2_soup_get_minor_version
+#define _soup_get_micro_version _ad2_soup_get_micro_version
+#define _soup_message_set_request_body_from_bytes _ad2_soup_message_set_request_body_from_bytes
+#define _soup_session_get_type _ad2_soup_session_get_type
+#define _soup_logger_log_level_get_type _ad2_soup_logger_log_level_get_type
+#define _soup_content_decoder_get_type _ad2_soup_content_decoder_get_type
+#define _soup_cookie_jar_get_type _ad2_soup_cookie_jar_get_type
+#define _soup_session_abort _ad2_soup_session_abort
+#define _soup_message_new _ad2_soup_message_new
+#define _soup_message_get_request_headers _ad2_soup_message_get_request_headers
+#define _soup_message_get_response_headers _ad2_soup_message_get_response_headers
+#define _soup_message_headers_remove _ad2_soup_message_headers_remove
+#define _soup_message_headers_append _ad2_soup_message_headers_append
+#define _soup_message_set_flags _ad2_soup_message_set_flags
+#define _soup_message_headers_foreach _ad2_soup_message_headers_foreach
+#define _soup_message_headers_get_encoding _ad2_soup_message_headers_get_encoding
+#define _soup_message_headers_get_content_length _ad2_soup_message_headers_get_content_length
+#define _soup_message_get_status _ad2_soup_message_get_status
+#define _soup_message_get_reason_phrase _ad2_soup_message_get_reason_phrase
+#define _soup_message_headers_get_one _ad2_soup_message_headers_get_one
+#define _soup_message_disable_feature _ad2_soup_message_disable_feature
+#define _soup_message_headers_get_content_type _ad2_soup_message_headers_get_content_type
+#define _soup_message_headers_get_content_range _ad2_soup_message_headers_get_content_range
+#define _soup_message_headers_set_range _ad2_soup_message_headers_set_range
+#define _soup_auth_authenticate _ad2_soup_auth_authenticate
+#define _soup_message_get_method _ad2_soup_message_get_method
+#define _soup_session_send_async _ad2_soup_session_send_async
+#define _soup_session_send_finish _ad2_soup_session_send_finish
+#define _soup_session_send _ad2_soup_session_send
+#define gst_soup_session_cancel_message ad2_gst_soup_session_cancel_message
+#endif
+
+G_BEGIN_DECLS
+
+gboolean gst_soup_load_library (void);
+guint gst_soup_loader_get_api_version (void);
+
+SoupSession *_soup_session_new_with_options (const char *optname1, ...) G_GNUC_NULL_TERMINATED;
+
+SoupLogger *_soup_logger_new (SoupLoggerLogLevel);
+
+void _soup_logger_set_printer (SoupLogger *logger, SoupLoggerPrinter printer,
+                               gpointer printer_data, GDestroyNotify destroy);
+
+void _soup_session_add_feature (SoupSession *session,
+                                SoupSessionFeature *feature);
+void _soup_session_add_feature_by_type (SoupSession *session, GType feature_type);
+
+typedef struct _GstSoupUri {
+#if (defined(STATIC_SOUP) && STATIC_SOUP == 3) || (!defined(STATIC_SOUP) && GLIB_CHECK_VERSION(2, 66, 0))
+  GUri *uri;
+#endif
+#if (defined(STATIC_SOUP) && STATIC_SOUP == 2) || !defined(STATIC_SOUP)
+  SoupURI *soup_uri;
+#endif
+} GstSoupUri;
+
+GstSoupUri *gst_soup_uri_new (const char *uri_string);
+void gst_soup_uri_free (GstSoupUri *uri);
+char *gst_soup_uri_to_string (GstSoupUri *uri);
+
+char *gst_soup_message_uri_to_string (SoupMessage* msg);
+
+guint _soup_get_major_version (void);
+guint _soup_get_minor_version (void);
+guint _soup_get_micro_version (void);
+
+void _soup_message_set_request_body_from_bytes (SoupMessage *msg,
+                                                const char *content_type,
+                                                GBytes *bytes);
+
+GType _soup_session_get_type (void);
+GType _soup_logger_log_level_get_type (void);
+GType _soup_content_decoder_get_type (void);
+GType _soup_cookie_jar_get_type (void);
+
+void _soup_session_abort (SoupSession * session);
+SoupMessage *_soup_message_new (const char *method, const char *uri_string);
+SoupMessageHeaders *_soup_message_get_request_headers (SoupMessage *msg);
+SoupMessageHeaders *_soup_message_get_response_headers (SoupMessage *msg);
+
+void _soup_message_headers_remove (SoupMessageHeaders *hdrs, const char *name);
+void _soup_message_headers_append (SoupMessageHeaders *hdrs, const char *name,
+                                   const char *value);
+void _soup_message_set_flags (SoupMessage *msg, SoupMessageFlags flags);
+
+void _soup_message_headers_foreach (SoupMessageHeaders *hdrs,
+                                    SoupMessageHeadersForeachFunc func,
+                                    gpointer user_data);
+
+SoupEncoding _soup_message_headers_get_encoding (SoupMessageHeaders *hdrs);
+
+goffset _soup_message_headers_get_content_length (SoupMessageHeaders *hdrs);
+
+SoupStatus _soup_message_get_status (SoupMessage *msg);
+const char *_soup_message_get_reason_phrase (SoupMessage *msg);
+
+const char *_soup_message_headers_get_one (SoupMessageHeaders *hdrs,
+                                           const char *name);
+void _soup_message_disable_feature (SoupMessage *msg, GType feature_type);
+
+const char *_soup_message_headers_get_content_type (SoupMessageHeaders *hdrs,
+                                                    GHashTable **params);
+
+gboolean _soup_message_headers_get_content_range (SoupMessageHeaders *hdrs,
+                                                   goffset *start, goffset *end,
+                                                   goffset *total_length);
+
+void _soup_message_headers_set_range (SoupMessageHeaders *hdrs, goffset start, goffset end);
+
+void _soup_auth_authenticate (SoupAuth *auth, const char *username,
+                              const char *password);
+
+const char *_soup_message_get_method (SoupMessage *msg);
+
+void _soup_session_send_async (SoupSession *session,
+                               SoupMessage *msg,
+                               GCancellable *cancellable,
+                               GAsyncReadyCallback callback,
+                               gpointer user_data);
+
+GInputStream *_soup_session_send_finish (SoupSession *session,
+                                         GAsyncResult *result, GError **error);
+
+GInputStream *_soup_session_send (SoupSession *session, SoupMessage *msg,
+                                  GCancellable *cancellable,
+                                  GError **error) G_GNUC_WARN_UNUSED_RESULT;
+
+void gst_soup_session_cancel_message (SoupSession *session, SoupMessage *msg, GCancellable *cancellable);
+
+G_END_DECLS
+
+#endif /* __GST_SOUP_LOADER_H__ */
diff --git a/ext/soup3/gstsouputils.c b/ext/soup3/gstsouputils.c
new file mode 100644
index 0000000..4357cd2
--- /dev/null
+++ b/ext/soup3/gstsouputils.c
@@ -0,0 +1,98 @@
+/* GStreamer
+ *
+ * Copyright (C) 2014 Samsung Electronics. All rights reserved.
+ *     @Author: Reynaldo H. Verdejo Pinochet <r.verdejo@sisa.samsung.com>
+ * Copyright (C) 2021 Igalia S.L.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+
+#include <glib.h>
+#include <gst/gst.h>
+#include "gstsouputils.h"
+#include "gstsouploader.h"
+
+/*
+ * Soup logger funcs
+ */
+
+GST_DEBUG_CATEGORY_EXTERN (soup_utils_debug);
+#define GST_CAT_DEFAULT soup_utils_debug
+
+static inline gchar
+gst_soup_util_log_make_level_tag (SoupLoggerLogLevel level)
+{
+  gchar c;
+
+  if (G_UNLIKELY ((gint) level > 9))
+    return '?';
+
+  switch (level) {
+    case SOUP_LOGGER_LOG_MINIMAL:
+      c = 'M';
+      break;
+    case SOUP_LOGGER_LOG_HEADERS:
+      c = 'H';
+      break;
+    case SOUP_LOGGER_LOG_BODY:
+      c = 'B';
+      break;
+    default:
+      /* Unknown level. If this is hit libsoup likely added a new
+       * log level to SoupLoggerLogLevel and it should be added
+       * as a case */
+      c = level + '0';
+      break;
+  }
+  return c;
+}
+
+static void
+gst_soup_util_log_printer_cb (SoupLogger G_GNUC_UNUSED * logger,
+    SoupLoggerLogLevel level, char direction, const char *data,
+    gpointer user_data)
+{
+  gchar c;
+  c = gst_soup_util_log_make_level_tag (level);
+  GST_TRACE_OBJECT (G_OBJECT (user_data), "HTTP_SESSION(%c): %c %s", c,
+      direction, data);
+}
+
+void
+gst_soup_util_log_setup (SoupSession * session, SoupLoggerLogLevel level,
+    GObject * object)
+{
+  SoupLogger *logger;
+
+  if (!level) {
+    GST_INFO_OBJECT (object, "Not attaching a logger with level 0");
+    return;
+  }
+
+  g_assert (session && object);
+
+  if (gst_debug_category_get_threshold (GST_CAT_DEFAULT)
+      < GST_LEVEL_TRACE) {
+    GST_INFO_OBJECT (object, "Not setting up HTTP session logger. "
+        "Need at least GST_LEVEL_TRACE");
+    return;
+  }
+
+  /* Create a new logger and set body_size_limit to -1 (no limit) */
+  logger = _soup_logger_new (level);
+
+  _soup_logger_set_printer (logger, gst_soup_util_log_printer_cb, object, NULL);
+
+  /* Attach logger to session */
+  _soup_session_add_feature (session, (SoupSessionFeature *) logger);
+  g_object_unref (logger);
+}
diff --git a/ext/soup3/gstsouputils.h b/ext/soup3/gstsouputils.h
new file mode 100644
index 0000000..2ac84a8
--- /dev/null
+++ b/ext/soup3/gstsouputils.h
@@ -0,0 +1,37 @@
+/* GStreamer
+ *
+ * Copyright (C) 2014 Samsung Electronics. All rights reserved.
+ *     @Author: Reynaldo H. Verdejo Pinochet <r.verdejo@sisa.samsung.com>
+ * Copyright (C) 2021 Igalia S.L.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+#ifndef __GST_SOUP_UTILS_H__
+#define __GST_SOUP_UTILS_H__
+
+#include <glib.h>
+#include <gst/gst.h>
+
+#ifdef STATIC_SOUP
+#include <libsoup/soup.h>
+#else
+#include "stub/soup.h"
+#endif
+
+G_BEGIN_DECLS
+
+void gst_soup_util_log_setup (SoupSession * session, SoupLoggerLogLevel level,
+    GObject * object);
+
+G_END_DECLS
+
+#endif
diff --git a/ext/soup3/meson.build b/ext/soup3/meson.build
new file mode 100644
index 0000000..1b1b6e6
--- /dev/null
+++ b/ext/soup3/meson.build
@@ -0,0 +1,30 @@
+soup_sources = [
+  'gstsoup.c',
+  'gstsoupelement.c',
+  'gstsouphttpclientsink.c',
+  'gstsouphttpsrc.c',
+  'gstsouploader.c',
+  'gstsouputils.c',
+]
+
+soup_opt = get_option('soup3')
+if soup_opt.disabled()
+  subdir_done()
+endif
+
+gmodule_dep = dependency('gmodule-2.0', fallback: ['glib', 'libgmodule_dep'])
+gobject_dep = dependency('gobject-2.0', fallback: ['glib', 'libgobject_dep'])
+
+libdl_dep = cc.find_library('dl', required: false)
+
+gstsouphttpsrc = library('gstsoup',
+  soup_sources,
+  c_args : gst_plugins_good_args,
+  link_args : noseh_link_args,
+  include_directories : [configinc, libsinc],
+  dependencies : [gst_dep, gstbase_dep, gsttag_dep, gmodule_dep, gobject_dep, gio_dep, libdl_dep],
+  install : true,
+  install_dir : plugins_install_dir,
+)
+pkgconfig.generate(gstsouphttpsrc, install_dir : plugins_pkgconfig_install_dir)
+plugins += [gstsouphttpsrc]
diff --git a/ext/soup3/stub/soup.h b/ext/soup3/stub/soup.h
new file mode 100644
index 0000000..56ddd6a
--- /dev/null
+++ b/ext/soup3/stub/soup.h
@@ -0,0 +1,214 @@
+/* GStreamer
+ * Copyright (C) 2021 Igalia S.L.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+#ifndef __GST_SOUP_STUB_H__
+#define __GST_SOUP_STUB_H__
+
+#include <glib.h>
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+typedef enum {
+	SOUP_LOGGER_LOG_NONE,
+	SOUP_LOGGER_LOG_MINIMAL,
+	SOUP_LOGGER_LOG_HEADERS,
+	SOUP_LOGGER_LOG_BODY
+} SoupLoggerLogLevel;
+
+typedef enum {
+  SOUP_MEMORY_STATIC,
+  SOUP_MEMORY_TAKE,
+  SOUP_MEMORY_COPY,
+  SOUP_MEMORY_TEMPORARY
+} SoupMemoryUse;
+
+typedef enum {
+  SOUP_MESSAGE_NO_REDIRECT = (1 << 1),
+  /* Removed from libsoup2. In libsoup3 this enum value is allocated to
+     SOUP_MESSAGE_IDEMPOTENT which we don't use in GStreamer. */
+  SOUP_MESSAGE_OVERWRITE_CHUNKS = (1 << 3),
+} SoupMessageFlags;
+
+typedef enum {
+  SOUP_ENCODING_UNRECOGNIZED,
+  SOUP_ENCODING_NONE,
+  SOUP_ENCODING_CONTENT_LENGTH,
+  SOUP_ENCODING_EOF,
+  SOUP_ENCODING_CHUNKED,
+  SOUP_ENCODING_BYTERANGES
+} SoupEncoding;
+
+typedef enum {
+  SOUP_STATUS_NONE,
+
+  /* Transport Errors */
+  SOUP_STATUS_CANCELLED = 1,
+  SOUP_STATUS_CANT_RESOLVE,
+  SOUP_STATUS_CANT_RESOLVE_PROXY,
+  SOUP_STATUS_CANT_CONNECT,
+  SOUP_STATUS_CANT_CONNECT_PROXY,
+  SOUP_STATUS_SSL_FAILED,
+  SOUP_STATUS_IO_ERROR,
+  SOUP_STATUS_MALFORMED,
+  SOUP_STATUS_TRY_AGAIN,
+  SOUP_STATUS_TOO_MANY_REDIRECTS,
+  SOUP_STATUS_TLS_FAILED,
+
+  SOUP_STATUS_CONTINUE = 100,
+  SOUP_STATUS_SWITCHING_PROTOCOLS = 101,
+  SOUP_STATUS_PROCESSING = 102, /* WebDAV */
+
+  SOUP_STATUS_OK = 200,
+  SOUP_STATUS_CREATED = 201,
+  SOUP_STATUS_ACCEPTED = 202,
+  SOUP_STATUS_NON_AUTHORITATIVE = 203,
+  SOUP_STATUS_NO_CONTENT = 204,
+  SOUP_STATUS_RESET_CONTENT = 205,
+  SOUP_STATUS_PARTIAL_CONTENT = 206,
+  SOUP_STATUS_MULTI_STATUS = 207, /* WebDAV */
+
+  SOUP_STATUS_MULTIPLE_CHOICES = 300,
+  SOUP_STATUS_MOVED_PERMANENTLY = 301,
+  SOUP_STATUS_FOUND = 302,
+  SOUP_STATUS_MOVED_TEMPORARILY = 302, /* RFC 2068 */
+  SOUP_STATUS_SEE_OTHER = 303,
+  SOUP_STATUS_NOT_MODIFIED = 304,
+  SOUP_STATUS_USE_PROXY = 305,
+  SOUP_STATUS_NOT_APPEARING_IN_THIS_PROTOCOL = 306, /* (reserved) */
+  SOUP_STATUS_TEMPORARY_REDIRECT = 307,
+  SOUP_STATUS_PERMANENT_REDIRECT = 308,
+
+  SOUP_STATUS_BAD_REQUEST = 400,
+  SOUP_STATUS_UNAUTHORIZED = 401,
+  SOUP_STATUS_PAYMENT_REQUIRED = 402, /* (reserved) */
+  SOUP_STATUS_FORBIDDEN = 403,
+  SOUP_STATUS_NOT_FOUND = 404,
+  SOUP_STATUS_METHOD_NOT_ALLOWED = 405,
+  SOUP_STATUS_NOT_ACCEPTABLE = 406,
+  SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED = 407,
+  SOUP_STATUS_PROXY_UNAUTHORIZED = SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED,
+  SOUP_STATUS_REQUEST_TIMEOUT = 408,
+  SOUP_STATUS_CONFLICT = 409,
+  SOUP_STATUS_GONE = 410,
+  SOUP_STATUS_LENGTH_REQUIRED = 411,
+  SOUP_STATUS_PRECONDITION_FAILED = 412,
+  SOUP_STATUS_REQUEST_ENTITY_TOO_LARGE = 413,
+  SOUP_STATUS_REQUEST_URI_TOO_LONG = 414,
+  SOUP_STATUS_UNSUPPORTED_MEDIA_TYPE = 415,
+  SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE = 416,
+  SOUP_STATUS_INVALID_RANGE = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE,
+  SOUP_STATUS_EXPECTATION_FAILED = 417,
+  SOUP_STATUS_MISDIRECTED_REQUEST = 421,  /* HTTP/2 */
+  SOUP_STATUS_UNPROCESSABLE_ENTITY = 422, /* WebDAV */
+  SOUP_STATUS_LOCKED = 423,               /* WebDAV */
+  SOUP_STATUS_FAILED_DEPENDENCY = 424,    /* WebDAV */
+
+  SOUP_STATUS_INTERNAL_SERVER_ERROR = 500,
+  SOUP_STATUS_NOT_IMPLEMENTED = 501,
+  SOUP_STATUS_BAD_GATEWAY = 502,
+  SOUP_STATUS_SERVICE_UNAVAILABLE = 503,
+  SOUP_STATUS_GATEWAY_TIMEOUT = 504,
+  SOUP_STATUS_HTTP_VERSION_NOT_SUPPORTED = 505,
+  SOUP_STATUS_INSUFFICIENT_STORAGE = 507, /* WebDAV search */
+  SOUP_STATUS_NOT_EXTENDED = 510          /* RFC 2774 */
+} SoupStatus;
+
+#define SOUP_STATUS_IS_SUCCESSFUL(status) ((status) >= 200 && (status) < 300)
+#define SOUP_STATUS_IS_REDIRECTION(status) ((status) >= 300 && (status) < 400)
+#define SOUP_STATUS_IS_CLIENT_ERROR(status) ((status) >= 400 && (status) < 500)
+#define SOUP_STATUS_IS_SERVER_ERROR(status) ((status) >= 500 && (status) < 600)
+#define SOUP_STATUS_IS_TRANSPORT_ERROR(status) ((status) > 0 && (status) < 100)
+
+typedef gpointer SoupSession;
+typedef gpointer SoupMessage;
+typedef gpointer SoupLogger;
+typedef gpointer SoupSessionFeature;
+typedef gpointer SoupURI;
+typedef gpointer SoupMessageBody;
+typedef gpointer SoupMessageHeaders;
+typedef gpointer SoupAuth;
+
+typedef struct _SoupMessage2 {
+  GObject parent;
+
+  /*< public >*/
+  const char *method;
+
+  guint status_code;
+  char *reason_phrase;
+
+  SoupMessageBody *request_body;
+  SoupMessageHeaders *request_headers;
+
+  SoupMessageBody *response_body;
+  SoupMessageHeaders *response_headers;
+} SoupMessage2;
+
+typedef void (*SoupLoggerPrinter)(SoupLogger *logger,
+                                                   SoupLoggerLogLevel level,
+                                                   char direction,
+                                                   const char *data,
+                                                   gpointer user_data);
+
+#if GLIB_CHECK_VERSION(2, 68, 0)
+#define SOUP_HTTP_URI_FLAGS                                                    \
+  (G_URI_FLAGS_HAS_PASSWORD | G_URI_FLAGS_ENCODED_PATH |                       \
+   G_URI_FLAGS_ENCODED_QUERY | G_URI_FLAGS_ENCODED_FRAGMENT |                  \
+   G_URI_FLAGS_SCHEME_NORMALIZE)
+#else
+#define SOUP_HTTP_URI_FLAGS                                                    \
+  (G_URI_FLAGS_HAS_PASSWORD | G_URI_FLAGS_ENCODED_PATH |                       \
+   G_URI_FLAGS_ENCODED_QUERY | G_URI_FLAGS_ENCODED_FRAGMENT)
+#endif
+
+typedef void (*SoupMessageHeadersForeachFunc)(const char *name,
+                                              const char *value,
+                                              gpointer user_data);
+
+/* Do not use these variables directly; use the macros above, which
+ * ensure that they get initialized properly.
+ */
+
+#if defined(__GNUC__)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wunused-variable"
+#endif
+static gpointer _SOUP_METHOD_OPTIONS;
+static gpointer _SOUP_METHOD_GET;
+static gpointer _SOUP_METHOD_HEAD;
+static gpointer _SOUP_METHOD_POST;
+#if defined(__GNUC__)
+#pragma GCC diagnostic pop
+#endif
+
+#define _SOUP_ATOMIC_INTERN_STRING(variable, value)                            \
+  ((const char *)(g_atomic_pointer_get(&(variable))                            \
+                      ? (variable)                                             \
+                      : (g_atomic_pointer_set(                                 \
+                             &(variable),                                      \
+                             (gpointer)g_intern_static_string(value)),         \
+                         (variable))))
+
+#define _SOUP_INTERN_METHOD(method)                                            \
+  (_SOUP_ATOMIC_INTERN_STRING(_SOUP_METHOD_##method, #method))
+
+#define SOUP_METHOD_OPTIONS _SOUP_INTERN_METHOD(OPTIONS)
+#define SOUP_METHOD_GET _SOUP_INTERN_METHOD(GET)
+#define SOUP_METHOD_HEAD _SOUP_INTERN_METHOD(HEAD)
+#define SOUP_METHOD_POST _SOUP_INTERN_METHOD(POST)
+
+G_END_DECLS
+
+#endif /* __GST_SOUP_STUB_H__ */
diff --git a/meson_options.txt b/meson_options.txt
index 5c96f65..0f1f946 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -67,6 +67,7 @@ option('pulse', type : 'feature', value : 'auto', description : 'Pulseaudio audi
 option('qt5', type : 'feature', value : 'auto', description : 'Qt5 QML video sink plugin')
 option('shout2', type : 'feature', value : 'auto', description : 'Shout-casting network sink plugin based on libshout2')
 option('soup', type : 'feature', value : 'auto', description : 'libsoup HTTP client source/sink plugin')
+option('soup3', type : 'feature', value : 'auto', description : 'libsoup HTTP client source/sink plugin using libsoup3')
 option('speex', type : 'feature', value : 'auto', description : 'Speex audio codec plugin')
 option('taglib', type : 'feature', value : 'auto', description : 'Tag-writing plugin based on taglib')
 option('twolame', type : 'feature', value : 'auto', description : 'twolame mp2 audio encoder plugin')
-- 
2.37.3

