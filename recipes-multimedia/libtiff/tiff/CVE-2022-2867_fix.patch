Date: Mon, 31 Oct 2022 10:57:14 +0000
From: NareshKumar M <NareshKumar_M@comcast.com>
Subject: CVE-2022-2867 
Source: https://gitlab.com/libtiff/libtiff/-/merge_requests/294/diffs?commit_id=7d7bfa4416366ec64068ac389414241ed4730a54 4a23da2060a21c1f03e208b12d63f5beb7c96262 Mon Sep 17 00:00:00 2001
Signed-off-by:  Su Laus / nm296(nareshkumar_m@comcast.com)

---
 tools/tiffcrop.c | 63 ++++++++++++++++++++++++++++++++----------------
 1 file changed, 42 insertions(+), 21 deletions(-)

diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index aca4690..97dc785 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -5153,20 +5153,33 @@ computeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,
 	y1 = (uint32) (crop->corners[i].Y1);
 	y2 = (uint32) (crop->corners[i].Y2);       
 	}
-       /* region needs to be within image sizes 0.. width-1; 0..length-1
-       * - be aware x,y are already casted to (uint32_t) and avoid (0 - 1)
-       */
-     if (x1 > image->width - 1)
-        crop->regionlist[i].x1 = image->width - 1;
-     else if (x1 > 0)
-        crop->regionlist[i].x1 = (uint32) (x1 - 1);
-
-      if (x2 > image->width - 1)
-       crop->regionlist[i].x2 = image->width - 1;
-     else if (x2 > 0)
-       crop->regionlist[i].x2 = (uint32_t)(x2 - 1);
-     
-     zwidth  = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1; 
+      /* a) Region needs to be within image sizes 0.. width-1; 0..length-1 
+       * b) Corners are expected to be submitted as top-left to bottom-right.
+       *    Therefore, check that and reorder input.
+       * (be aware x,y are already casted to (uint32_t) and avoid (0 - 1) )
+      */
+      uint32_t aux;
+      if (x1 > x2) {
+        aux = x1;
+        x1 = x2;
+        x2 = aux;
+      }
+      if (y1 > y2) {
+        aux = y1;
+        y1 = y2;
+        y2 = aux;
+      }
+      if (x1 > image->width - 1) 
+	crop->regionlist[i].x1 = image->width - 1;
+      else if (x1 > 0)
+        crop->regionlist[i].x1 = (uint32_t)(x1 - 1);
+
+     if (x2 > image->width - 1)
+        crop->regionlist[i].x2 = image->width - 1;
+      else if (x2 > 0)
+        crop->regionlist[i].x2 = (uint32_t)(x2 - 1);
+
+     zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1; 
 
       if (y1 > image->length - 1)
         crop->regionlist[i].y1 = image->length - 1;
@@ -5179,7 +5192,6 @@ computeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,
         crop->regionlist[i].y2 = (uint32_t)(y2 - 1);
 
       zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1; 
-
       if (zwidth > max_width)
         max_width = zwidth;
       if (zlength > max_length)
@@ -5209,7 +5221,7 @@ computeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,
 	}
       }
     return (0);
-    }
+    }  /* crop_mode == CROP_REGIONS */
   
   /* Convert crop margins into offsets into image
    * Margins are expressed as pixel rows and columns, not bytes
@@ -5245,7 +5257,7 @@ computeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,
       bmargin = (uint32) 0;
       return (-1);
       }
-    }
+    }  /* crop_mode == CROP_MARGINS */
   else
     { /* no margins requested */
     tmargin = (uint32) 0;
@@ -5453,11 +5465,17 @@ getCropOffsets(struct image_data *image, struct crop_mask *crop, struct dump_opt
   else
     crop->selections = crop->zones;
 
-  for (i = 0; i < crop->zones; i++)
+    /* Initialize regions iterator i */
+  i = 0;
+  for (int j = 0; j < crop->zones; j++)
     {
-    seg = crop->zonelist[i].position;
-    total = crop->zonelist[i].total;
+    seg = crop->zonelist[j].position;
+    total = crop->zonelist[j].total;
 
+    /* check for not allowed zone cases like 0:0; 4:3; etc. and skip that input */
+    if (seg == 0 || total == 0 || seg > total) {
+        continue;
+    }
     switch (crop->edge_ref) 
       {
       case EDGE_LEFT: /* zones from left to right, length from top */
@@ -5585,8 +5603,11 @@ getCropOffsets(struct image_data *image, struct crop_mask *crop, struct dump_opt
                     i + 1, (uint32)zwidth, (uint32)zlength,
 		    crop->regionlist[i].x1, crop->regionlist[i].x2, 
                     crop->regionlist[i].y1, crop->regionlist[i].y2);
+    /* increment regions iterator */
+  i++;
     }
-
+    /* set number of generated regions out of given zones */
+    crop->selections = i;
   return (0);
   } /* end getCropOffsets */
 
